# Классы, объекты и ООП в Java: от первого `new` до production-кода

## Оглавление
- [Оглавление](#%D0%9E%D0%B3%D0%BB%D0%B0%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5)
- [1. Классы и объекты](#1.%20%D0%9A%D0%BB%D0%B0%D1%81%D1%81%D1%8B%20%D0%B8%20%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D1%8B)
	- [1.1 Концепт](#1.1%20%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82)
	- [1.2 Hello World](#1.2%20Hello%20World)
		- [Статус заказа](#%D0%A1%D1%82%D0%B0%D1%82%D1%83%D1%81%20%D0%B7%D0%B0%D0%BA%D0%B0%D0%B7%D0%B0)
		- [Позиция заказа](#%D0%9F%D0%BE%D0%B7%D0%B8%D1%86%D0%B8%D1%8F%20%D0%B7%D0%B0%D0%BA%D0%B0%D0%B7%D0%B0)
		- [Заказ](#%D0%97%D0%B0%D0%BA%D0%B0%D0%B7)
		- [Создание и использование](#%D0%A1%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B8%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
	- [1.3 Under the Hood: что происходит при `new Order(...)`](#1.3%20Under%20the%20Hood:%20%D1%87%D1%82%D0%BE%20%D0%BF%D1%80%D0%BE%D0%B8%D1%81%D1%85%D0%BE%D0%B4%D0%B8%D1%82%20%D0%BF%D1%80%D0%B8%C2%A0%60new%20Order(...)%60)
		- [Object Header](#Object%20Header)
		- [Раскладка полей](#%D0%A0%D0%B0%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%BA%D0%B0%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9)
		- [Аллокация: TLAB и bump pointer](#%D0%90%D0%BB%D0%BB%D0%BE%D0%BA%D0%B0%D1%86%D0%B8%D1%8F:%20TLAB%20%D0%B8%20bump%20pointer)
	- [1.4 Production Grade](#1.4%20Production%20Grade)
		- [Юнит-тесты](#%D0%AE%D0%BD%D0%B8%D1%82-%D1%82%D0%B5%D1%81%D1%82%D1%8B)
	- [1.5 Edge Cases](#1.5%20Edge%20Cases)
- [2. Инкапсуляция](#2.%20%D0%98%D0%BD%D0%BA%D0%B0%D0%BF%D1%81%D1%83%D0%BB%D1%8F%D1%86%D0%B8%D1%8F)
	- [2.1 Концепт](#2.1%20%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82)
	- [2.2 Hello World](#2.2%20Hello%20World)
		- [Таблица модификаторов доступа](#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0%20%D0%BC%D0%BE%D0%B4%D0%B8%D1%84%D0%B8%D0%BA%D0%B0%D1%82%D0%BE%D1%80%D0%BE%D0%B2%20%D0%B4%D0%BE%D1%81%D1%82%D1%83%D0%BF%D0%B0)
	- [2.3 Under the Hood](#2.3%20Under%20the%20Hood)
	- [2.4 Production Grade: record как DTO](#2.4%20Production%20Grade:%20record%20%D0%BA%D0%B0%D0%BA%20DTO)
	- [2.5 Edge Cases](#2.5%20Edge%20Cases)
- [3. Наследование](#3.%20%D0%9D%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
	- [3.1 Концепт](#3.1%20%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82)
	- [3.2 Hello World](#3.2%20Hello%20World)
		- [Базовый класс](#%D0%91%D0%B0%D0%B7%D0%BE%D0%B2%D1%8B%D0%B9%20%D0%BA%D0%BB%D0%B0%D1%81%D1%81)
		- [Подклассы](#%D0%9F%D0%BE%D0%B4%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D1%8B)
		- [Использование — полиморфизм в действии](#%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%E2%80%94%20%D0%BF%D0%BE%D0%BB%D0%B8%D0%BC%D0%BE%D1%80%D1%84%D0%B8%D0%B7%D0%BC%20%D0%B2%20%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%B8%D0%B8)
	- [3.3 Under the Hood: наследование в памяти](#3.3%20Under%20the%20Hood:%20%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B2%20%D0%BF%D0%B0%D0%BC%D1%8F%D1%82%D0%B8)
		- [Цепочка инициализации](#%D0%A6%D0%B5%D0%BF%D0%BE%D1%87%D0%BA%D0%B0%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
	- [3.4 Production Grade: Template Method](#3.4%20Production%20Grade:%20Template%20Method)
	- [3.5 Edge Cases](#3.5%20Edge%20Cases)
		- [Вызов переопределяемого метода из конструктора](#%D0%92%D1%8B%D0%B7%D0%BE%D0%B2%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BE%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D1%8F%D0%B5%D0%BC%D0%BE%D0%B3%D0%BE%20%D0%BC%D0%B5%D1%82%D0%BE%D0%B4%D0%B0%20%D0%B8%D0%B7%20%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%BA%D1%82%D0%BE%D1%80%D0%B0)
		- [Проблема с `equals()` в иерархии наследования](#%D0%9F%D1%80%D0%BE%D0%B1%D0%BB%D0%B5%D0%BC%D0%B0%20%D1%81%C2%A0%60equals()%60%C2%A0%D0%B2%20%D0%B8%D0%B5%D1%80%D0%B0%D1%80%D1%85%D0%B8%D0%B8%20%D0%BD%D0%B0%D1%81%D0%BB%D0%B5%D0%B4%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)



---

## 1. Классы и объекты

### 1.1 Концепт

Представьте бланк заказа в интернет-магазине — тот самый шаблон, который распечатывают на складе.

| Термин ООП      | Аналогия                                                 | Суть                                                      |
| --------------- | -------------------------------------------------------- | --------------------------------------------------------- |
| **Класс**       | Бланк заказа (шаблон)                                    | Описывает, какие данные хранить и какие действия доступны |
| **Объект**      | Заполненный заказ №12345                                 | Конкретный экземпляр с реальными данными                  |
| **Поля**        | Графы бланка: номер, товары, сумма                       | Данные, которые хранит объект                             |
| **Методы**      | Действия: рассчитать итог, отменить                      | Операции, которые объект умеет выполнять                  |
| **Конструктор** | Процедура оформления: проверить, заполнить, выдать номер | Код, который выполняется при создании объекта             |

Аналогия помогает схватить суть, но у неё есть границы. Бланк — это пассивная бумажка. Класс в Java — это нечто большее: он определяет **инварианты** (правила, которые объект обязан соблюдать всю свою жизнь) и **контролирует доступ** к своим данным. Эти вещи мы разберём дальше на коде.

---

### 1.2 Hello World

Начнём с простых вещей и будем усложнять постепенно.

#### Статус заказа



```java
package com.ecommerce.model;

/**
 * Возможные статусы заказа.
 *
 * enum — специальный вид класса в Java. Его экземпляры
 * фиксированы и создаются один раз при загрузке класса JVM
 * (не при компиляции, а при первом обращении в runtime).
 */
public enum OrderStatus {
    PENDING,     // Ожидает обработки
    CONFIRMED,   // Подтверждён
    SHIPPED,     // Отправлен
    DELIVERED,   // Доставлен
    CANCELLED    // Отменён
}
```

#### Позиция заказа

Позиция — это один товар с количеством и ценой. Начнём с обычного класса, чтобы видеть все детали:


```java
package com.ecommerce.model;

import java.math.BigDecimal;

/**
 * Позиция в заказе — один товар с количеством и ценой.
 *
 * Почему BigDecimal, а не double?
 * Потому что double теряет копейки:
 *   double result = 0.1 + 0.2;  // → 0.30000000000000004
 * BigDecimal считает точно:
 *   new BigDecimal("0.1").add(new BigDecimal("0.2"))  // → 0.3
 */
public class LineItem {

    // private — поле доступно только внутри этого класса.
    // final  — значение присваивается один раз и больше не меняется.
    private final String productId;
    private final int quantity;
    private final BigDecimal price;

    /**
     * Конструктор — вызывается при создании объекта (new LineItem(...)).
     * Его имя совпадает с именем класса, возвращаемого типа нет.
     */
    public LineItem(String productId, int quantity, BigDecimal price) {
        // Валидация: проверяем входные данные сразу.
        // Принцип "fail fast": лучше упасть здесь с понятной ошибкой,
        // чем получить странный баг через 500 строк кода.

        if (productId == null || productId.isBlank()) {
            throw new IllegalArgumentException(
                "Product ID must not be null or blank"
            );
        }
        if (price == null) {
            throw new IllegalArgumentException("Price must not be null");
        }
        if (quantity <= 0) {
            throw new IllegalArgumentException(
                "Quantity must be positive, got: " + quantity
            );
        }
        if (price.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException(
                "Price must not be negative, got: " + price
            );
        }

        this.productId = productId;
        this.quantity = quantity;
        this.price = price;
    }

    /**
     * Стоимость позиции: цена × количество.
     */
    public BigDecimal total() {
        return price.multiply(BigDecimal.valueOf(quantity));
    }

    // Геттеры — контролируемый доступ к private-полям.
    public String getProductId() { return productId; }
    public int getQuantity() { return quantity; }
    public BigDecimal getPrice() { return price; }

    @Override
    public String toString() {
        return String.format("LineItem{productId='%s', qty=%d, price=%s}",
            productId, quantity, price);
    }
}
```

#### Заказ

Теперь — главный класс:


```java
package com.ecommerce.model;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Заказ в интернет-магазине.
 *
 * Это основная сущность нашего примера. Каждый заказ имеет
 * уникальный идентификатор, список позиций, статус и время создания.
 *
 * Класс НЕ потокобезопасен: если несколько потоков работают
 * с одним и тем же объектом Order одновременно, нужна внешняя
 * синхронизация. В однопоточном коде (и в большинстве учебных примеров)
 * это не проблема.
 */
public class Order {

    private final String orderId;
    private final List<LineItem> items;
    private final Instant createdAt;
    private BigDecimal totalAmount;
    private OrderStatus status;

    /**
     * Создаёт новый заказ.
     *
     * @param orderId уникальный идентификатор (не null, не blank)
     * @param items   список позиций (не null, не пустой, без null-элементов)
     */
    public Order(String orderId, List<LineItem> items) {
        // --- Валидация ---

        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID must not be null or blank");
        }
        if (items == null) {
            throw new IllegalArgumentException("Items must not be null");
        }
        if (items.isEmpty()) {
            throw new IllegalArgumentException("Order must contain at least one item");
        }

        // Проверяем, что внутри списка нет null-элементов.
        // Без этой проверки null проскочит в items, а NullPointerException
        // вылетит позже — в calculateTotal() — и будет непонятно, откуда он.
        for (LineItem item : items) {
            if (item == null) {
                throw new IllegalArgumentException("Items must not contain null elements");
            }
        }

        this.orderId = orderId;

        // DEFENSIVE COPY — критически важный приём.
        // Мы создаём НОВЫЙ список с теми же элементами,
        // а не сохраняем ссылку на переданный.
        //
        // Зачем? Потому что вызывающий код может изменить свой список:
        //   List<LineItem> myItems = new ArrayList<>();
        //   myItems.add(item1);
        //   Order order = new Order("ORD-001", myItems);
        //   myItems.clear();  // Без defensive copy это очистит items внутри Order!
        //
        // new ArrayList<>(items) копирует элементы в новый независимый список.
        this.items = new ArrayList<>(items);

        this.status = OrderStatus.PENDING;
        this.createdAt = Instant.now();
        this.totalAmount = calculateTotal();
    }

    /**
     * Рассчитывает итоговую сумму заказа.
     *
     * Возвращает результат. НЕ изменяет состояние объекта —
     * это чистая функция (pure function), которая зависит только от items.
     */
    public BigDecimal calculateTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        for (LineItem item : items) {
            sum = sum.add(item.total());
        }
        return sum;
    }

    /**
     * Отменяет заказ.
     *
     * Бизнес-правило: отменить можно только заказ
     * в статусе PENDING или CONFIRMED.
     */
    public void cancel() {
        if (status != OrderStatus.PENDING && status != OrderStatus.CONFIRMED) {
            throw new IllegalStateException(
                "Cannot cancel order in status: " + status
            );
        }
        this.status = OrderStatus.CANCELLED;
    }

    // --- Геттеры ---

    public String getOrderId() {
        return orderId;  // String неизменяем — можно возвращать напрямую
    }

    /**
     * Возвращает список позиций, защищённый от изменения извне.
     *
     * Collections.unmodifiableList — обёртка, запрещающая add/remove/clear.
     * Попытка изменить → UnsupportedOperationException.
     *
     * Это НЕ копия: мы не тратим память на дублирование,
     * а просто запрещаем модификацию через эту ссылку.
     */
    public List<LineItem> getItems() {
        return Collections.unmodifiableList(items);
    }

    public BigDecimal getTotalAmount() { return totalAmount; }
    public OrderStatus getStatus() { return status; }
    public Instant getCreatedAt() { return createdAt; }

    @Override
    public String toString() {
        return String.format(
            "Order{id='%s', items=%d, total=%s, status=%s}",
            orderId, items.size(), totalAmount, status
        );
    }
}
```

#### Создание и использование

```java
package com.ecommerce;

import com.ecommerce.model.LineItem;
import com.ecommerce.model.Order;

import java.math.BigDecimal;
import java.util.List;

public class OrderDemo {

    public static void main(String[] args) {
        // Создаём позиции заказа
        List<LineItem> items = List.of(
            new LineItem("SKU-1001", 2, new BigDecimal("29.99")),  // 2 × $29.99
            new LineItem("SKU-2002", 1, new BigDecimal("149.50"))  // 1 × $149.50
        );

        // Создаём заказ.
        // new Order(...) делает следующее:
        // 1. JVM выделяет память для объекта Order в куче (Heap)
        // 2. Вызывается конструктор — валидация, инициализация полей
        // 3. Ссылка на объект записывается в переменную order
        //
        // Переменная order — это «пульт от телевизора» (ссылка).
        // Сам объект — это «телевизор», стоящий в куче.
        Order order = new Order("ORD-001", items);

        System.out.println(order);
        // Order{id='ORD-001', items=2, total=209.48, status=PENDING}

        System.out.println("Total: $" + order.getTotalAmount());
        // Total: $209.48

        // Отменяем заказ
        order.cancel();
        System.out.println("After cancel: " + order.getStatus());
        // After cancel: CANCELLED

        // Повторная отмена — ошибка: заказ уже отменён
        try {
            order.cancel();
        } catch (IllegalStateException e) {
            System.out.println("Expected error: " + e.getMessage());
            // Expected error: Cannot cancel order in status: CANCELLED
        }
    }
}
```

---

### 1.3 Under the Hood: что происходит при `new Order(...)`

Когда вы пишете `Order order = new Order("ORD-001", items)`, под капотом происходит разделение: **ссылка** живёт на стеке, **объект** — в куче.

text

```
┌─────────────────────┐     ┌──────────────────────────────────────────┐
│    STACK             │     │    HEAP                                  │
│  (кадр метода main)  │     │                                          │
│                     │     │  ┌──────────────────────────────────┐    │
│  order ─────────────────────►│ Object Header                   │    │
│  (ссылка)            │     │  ├──────────────────────────────────┤    │
│                     │     │  │ orderId     (ссылка) ──────────────► String "ORD-001"
│                     │     │  │ items       (ссылка) ──────────────► ArrayList
│                     │     │  │ totalAmount (ссылка) ──────────────► BigDecimal
│                     │     │  │ status      (ссылка) ──────────────► OrderStatus.PENDING
│                     │     │  │ createdAt   (ссылка) ──────────────► Instant
│                     │     │  └──────────────────────────────────┘    │
└─────────────────────┘     └──────────────────────────────────────────┘
```

#### Object Header

Каждый объект в куче начинается с заголовка (Object Header). В HotSpot JVM на 64-bit платформе он обычно состоит из:

- **Mark Word** (8 байт) — служебная информация: состояние блокировки (для синхронизации), identity hash code (вычисляется лениво, при первом вызове), возраст объекта для сборщика мусора.
- **Klass Pointer** (4 или 8 байт, в зависимости от настроек JVM) — указатель на метаданные класса. По нему JVM знает, что этот объект — `Order`, а не `String`.

> **Важно:** Конкретные размеры зависят от версии JDK, платформы и флагов JVM (`UseCompressedOops`, `UseCompressedClassPointers`, `ObjectAlignmentInBytes`). Схема выше — типичная картина для HotSpot 64-bit с настройками по умолчанию, а не гарантированный контракт.

#### Раскладка полей

После заголовка идут поля объекта. JVM может **переупорядочить** поля для оптимального выравнивания — порядок в исходном коде не обязательно совпадает с порядком в памяти.

Проверить реальную раскладку можно с помощью **JOL** (Java Object Layout):


```java
// Зависимость: org.openjdk.jol:jol-core:0.17
import org.openjdk.jol.info.ClassLayout;

Order order = new Order("ORD-001", items);
System.out.println(ClassLayout.parseInstance(order).toPrintable());
```

Вывод JOL зависит от конкретной JVM и платформы — не удивляйтесь, если числа отличаются от ожидаемых. В этом и ценность инструмента: он показывает **реальность**, а не теорию.

#### Аллокация: TLAB и bump pointer

Когда JVM выполняет `new`, она не лезет в общую кучу каждый раз. Каждый поток имеет свой **TLAB** (Thread-Local Allocation Buffer) — небольшой кусочек памяти в Eden Space. Аллокация в TLAB — это просто сдвиг указателя (bump pointer), без синхронизации между потоками.

Когда TLAB заканчивается, поток запрашивает новый у JVM — это дороже. Когда заполняется Eden Space — запускается minor GC.

> **Практический вывод:** Каждый `new` — это аллокация минимум 16 байт (header + выравнивание). В горячем коде, который выполняется миллионы раз, избыточные аллокации — главный враг производительности. Но не оптимизируйте преждевременно: JIT-компилятор умеет устранять аллокации через escape analysis. Измеряйте с помощью JMH, прежде чем оптимизировать.

---

### 1.4 Production Grade

В реальном проекте класс Order обрастает логированием, более строгой валидацией и документацией. Вот ключевые отличия от учебной версии:


```java
package com.ecommerce.model.prod;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Заказ — production-версия.
 *
 * Ключевые отличия от учебной:
 * - Логирование через SLF4J (а не System.out)
 * - Более строгая валидация
 * - Документация ограничений (не потокобезопасен)
 *
 * НЕ потокобезопасен. Если объект разделяется между потоками,
 * необходима внешняя синхронизация.
 */
public class ProductionOrder {

    // Logger — один на все экземпляры класса.
    // static — принадлежит классу, а не объекту.
    // final — ссылка не переназначается.
    private static final Logger log = LoggerFactory.getLogger(ProductionOrder.class);

    private final String orderId;
    private final List<LineItem> items;
    private final Instant createdAt;
    private BigDecimal totalAmount;
    private OrderStatus status;

    public ProductionOrder(String orderId, List<LineItem> items) {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID must not be null or blank");
        }
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("Items must not be null or empty");
        }
        for (LineItem item : items) {
            if (item == null) {
                throw new IllegalArgumentException("Items must not contain null");
            }
        }

        this.orderId = orderId;
        this.items = new ArrayList<>(items);  // defensive copy
        this.status = OrderStatus.PENDING;
        this.createdAt = Instant.now();
        this.totalAmount = calculateTotal();

        // SLF4J плейсхолдеры {} подставляются ТОЛЬКО если уровень INFO включён.
        // Это эффективнее конкатенации: "Order created: " + orderId
        log.info("Order created: {}, items: {}, total: {}",
            orderId, items.size(), totalAmount);
    }

    public BigDecimal calculateTotal() {
        BigDecimal sum = BigDecimal.ZERO;
        for (LineItem item : items) {
            sum = sum.add(item.total());
        }
        return sum;
    }

    public void cancel() {
        if (status != OrderStatus.PENDING && status != OrderStatus.CONFIRMED) {
            log.warn("Attempt to cancel order {} in status {}", orderId, status);
            throw new IllegalStateException("Cannot cancel order in status: " + status);
        }
        this.status = OrderStatus.CANCELLED;
        log.info("Order cancelled: {}", orderId);
    }

    public String getOrderId() { return orderId; }
    public List<LineItem> getItems() { return Collections.unmodifiableList(items); }
    public BigDecimal getTotalAmount() { return totalAmount; }
    public OrderStatus getStatus() { return status; }
    public Instant getCreatedAt() { return createdAt; }

    /**
     * toString() для диагностики — БЕЗ чувствительных данных.
     * Логи попадают в ELK/Splunk/CloudWatch, где их видят десятки людей.
     * Данные покупателя, адрес, платёжные реквизиты — НИКОГДА не в toString().
     */
    @Override
    public String toString() {
        return String.format(
            "Order{id='%s', itemCount=%d, total=%s, status=%s, created=%s}",
            orderId, items.size(), totalAmount, status, createdAt
        );
    }
}
```

#### Юнит-тесты

```java
package com.ecommerce.model;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class OrderTest {

    private List<LineItem> createSampleItems() {
        return List.of(
            new LineItem("SKU-001", 2, new BigDecimal("10.00")),
            new LineItem("SKU-002", 1, new BigDecimal("25.50"))
        );
    }

    @Test
    @DisplayName("Should create order with valid data")
    void shouldCreateOrderWithValidData() {
        Order order = new Order("ORD-001", createSampleItems());

        assertEquals("ORD-001", order.getOrderId());
        assertEquals(2, order.getItems().size());
        // 2 × $10.00 + 1 × $25.50 = $45.50
        // Внимание: BigDecimal.equals() учитывает scale.
        // new BigDecimal("45.50").equals(new BigDecimal("45.5")) → false!
        // Если способ расчёта изменится, используйте compareTo() == 0.
        assertEquals(new BigDecimal("45.50"), order.getTotalAmount());
        assertEquals(OrderStatus.PENDING, order.getStatus());
        assertNotNull(order.getCreatedAt());
    }

    @Test
    @DisplayName("Should reject null orderId")
    void shouldThrowWhenOrderIdIsNull() {
        IllegalArgumentException ex = assertThrows(
            IllegalArgumentException.class,
            // () -> ... — это лямбда-выражение: "блок кода, который нужно выполнить".
            // assertThrows выполнит этот блок и проверит, что вылетит исключение.
            () -> new Order(null, createSampleItems())
        );
        assertTrue(ex.getMessage().contains("Order ID"));
    }

    @Test
    @DisplayName("Should reject empty items list")
    void shouldThrowWhenItemsEmpty() {
        assertThrows(
            IllegalArgumentException.class,
            () -> new Order("ORD-001", Collections.emptyList())
        );
    }

    @Test
    @DisplayName("Should reject null items")
    void shouldThrowWhenItemsNull() {
        assertThrows(
            IllegalArgumentException.class,
            () -> new Order("ORD-001", null)
        );
    }

    @Test
    @DisplayName("External list modification should not affect order (defensive copy)")
    void shouldNotBeAffectedByExternalListModification() {
        List<LineItem> mutableItems = new ArrayList<>();
        mutableItems.add(new LineItem("SKU-001", 1, new BigDecimal("10.00")));

        Order order = new Order("ORD-001", mutableItems);

        // Изменяем ВНЕШНИЙ список
        mutableItems.add(new LineItem("SKU-002", 1, new BigDecimal("20.00")));

        // Заказ не изменился — конструктор сделал defensive copy
        assertEquals(1, order.getItems().size());
    }

    @Test
    @DisplayName("Returned items list should be unmodifiable")
    void shouldReturnUnmodifiableItemsList() {
        Order order = new Order("ORD-001", createSampleItems());

        List<LineItem> returnedItems = order.getItems();
        assertThrows(
            UnsupportedOperationException.class,
            () -> returnedItems.clear()
        );
    }

    @Test
    @DisplayName("Should cancel pending order")
    void shouldCancelPendingOrder() {
        Order order = new Order("ORD-001", createSampleItems());
        order.cancel();
        assertEquals(OrderStatus.CANCELLED, order.getStatus());
    }

    @Test
    @DisplayName("Should throw when cancelling already cancelled order")
    void shouldThrowWhenCancellingCancelledOrder() {
        Order order = new Order("ORD-001", createSampleItems());
        order.cancel();

        assertThrows(
            IllegalStateException.class,
            () -> order.cancel()
        );
    }
}
```

---

### 1.5 Edge Cases

```java
package com.ecommerce.edgecases;

import com.ecommerce.model.LineItem;
import com.ecommerce.model.Order;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.List;

/**
 * Граничные случаи при работе с объектами.
 */
public class OrderEdgeCases {

    public static void main(String[] args) {

        List<LineItem> items = List.of(
            new LineItem("SKU-001", 1, new BigDecimal("10.00"))
        );

        // --- 1. Объект без переменной ---
        // Можно написать new Order(...) без присвоения.
        // Конструктор выполнится (валидация, логирование — все побочные эффекты),
        // но ссылка нигде не сохранится.
        // Объект станет eligible для сборки мусора (GC).
        // "Eligible" ≠ "немедленно собран": GC запустится когда сочтёт нужным.
        new Order("ORD-ORPHAN", items); // IDE предупредит: результат не используется

        // --- 2. Без валидации null проявится ПОЗЖЕ ---
        // Если бы конструктор НЕ проверял null:
        //   this.orderId = orderId;  // null сохранился бы тихо
        // NullPointerException вылетит позже, в другом методе:
        //   order.toString() → orderId.length() → NPE
        // Stack trace укажет на toString(), а не на место,
        // где null был передан. Отлаживать такое — мучение.
        //
        // С валидацией ошибка видна СРАЗУ:
        try {
            new Order(null, items);
        } catch (IllegalArgumentException e) {
            System.out.println("Caught early: " + e.getMessage());
            // Caught early: Order ID must not be null or blank
        }

        // --- 3. Defensive copy защищает от внешних изменений ---
        ArrayList<LineItem> mutableItems = new ArrayList<>();
        mutableItems.add(new LineItem("SKU-001", 1, new BigDecimal("10.00")));

        Order order = new Order("ORD-002", mutableItems);
        System.out.println("Before clear: " + order.getItems().size()); // 1

        // Изменяем ВНЕШНИЙ список — заказ не затронут
        mutableItems.clear();
        System.out.println("After clear:  " + order.getItems().size()); // 1

        // Если бы конструктор делал this.items = items (без копии),
        // после clear() внутренний список тоже опустел бы.
    }
}
```

---

## 2. Инкапсуляция

### 2.1 Концепт

Представьте платёжный терминал в магазине. Покупатель видит экран с суммой и кнопку «Оплатить». Он не видит внутренние протоколы связи с банком, retry-логику при сбое сети, шифрование данных карты. И не должен — это не его зона ответственности.

**Инкапсуляция** — это не просто «спрятать поля за private». Это **контролируемый доступ**, который защищает **инварианты** объекта.

**Инвариант** — условие, которое должно быть истинным ВСЕГДА в течение жизни объекта. Примеры:

- «Сумма платежа всегда положительная»
- «Статус не может перейти из COMPLETED обратно в PENDING»
- «Список товаров в заказе никогда не пуст»

Если внешний код может напрямую записать `payment.amount = -100`, инвариант нарушен. Инкапсуляция не даёт этого сделать.

---

### 2.2 Hello World

```java
package com.ecommerce.model;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.UUID;

/**
 * Платёж в интернет-магазине.
 *
 * Демонстрирует инкапсуляцию:
 * - private поля: данные доступны только через методы
 * - public методы: внешний API — process(), refund(), getStatus()
 * - private методы: внутренняя реализация — validateCard(), connectToGateway()
 *
 * НЕ потокобезопасен. В многопоточной среде два потока могут
 * одновременно вызвать process(), оба пройдут проверку status == PENDING
 * и оба начнут процессинг. Для потокобезопасности нужна синхронизация
 * (synchronized, Lock, AtomicReference) — это тема отдельной статьи.
 */
public class Payment {

    public enum Status {
        PENDING, PROCESSING, COMPLETED, FAILED, REFUNDED
    }

    // --- Private поля ---
    // Доступ к ним — только через методы этого класса.

    private final String paymentId;
    private final BigDecimal amount;
    private final String orderId;
    private final Instant createdAt;

    private Status status;
    private Instant updatedAt;

    // Токен карты — ЧУВСТВИТЕЛЬНЫЕ ДАННЫЕ.
    // Никогда не попадает в toString(), логи, API-ответы.
    // В реальном приложении хранят токен платёжного шлюза, а не данные карты.
    private final String cardToken;

    public Payment(String orderId, BigDecimal amount, String cardToken) {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID must not be null or blank");
        }
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive, got: " + amount);
        }
        if (cardToken == null || cardToken.isBlank()) {
            throw new IllegalArgumentException("Card token must not be null or blank");
        }

        this.orderId = orderId;
        this.amount = amount;
        this.cardToken = cardToken;

        // UUID.randomUUID() генерирует 128-битный идентификатор.
        // Для production используйте полный UUID или ID от платёжного шлюза.
        this.paymentId = "PAY-" + UUID.randomUUID();

        this.status = Status.PENDING;
        this.createdAt = Instant.now();
        this.updatedAt = this.createdAt;
    }

    // --- Public методы (внешний API) ---
    // Это «кнопки на терминале» — то, что видит вызывающий код.

    /**
     * Обрабатывает платёж.
     *
     * Единственный способ запустить обработку. Вызывающий код
     * не может напрямую выставить status = COMPLETED —
     * только через этот метод, который сам проверяет условия.
     *
     * @return true если платёж прошёл успешно
     * @throws IllegalStateException если платёж уже обработан
     */
    public boolean process() {
        if (status != Status.PENDING) {
            throw new IllegalStateException(
                "Cannot process payment in status: " + status
            );
        }

        this.status = Status.PROCESSING;
        this.updatedAt = Instant.now();

        try {
            // Вызываем private методы — внутреннюю реализацию.
            // Вызывающий код не знает, что они существуют.
            validateCard();
            connectToGateway();

            this.status = Status.COMPLETED;
            this.updatedAt = Instant.now();
            return true;

        } catch (Exception e) {
            this.status = Status.FAILED;
            this.updatedAt = Instant.now();
            // В production здесь обязательно логирование причины:
            // log.error("Payment failed for order {}", orderId, e);
            return false;
        }
    }

    /**
     * Возврат средств. Возможен только для завершённого платежа.
     */
    public void refund() {
        if (status != Status.COMPLETED) {
            throw new IllegalStateException(
                "Can only refund completed payments, current status: " + status
            );
        }
        this.status = Status.REFUNDED;
        this.updatedAt = Instant.now();
    }

    // --- Private методы (внутренняя реализация) ---
    // Это «внутренности терминала» — вызывающий код не может их вызвать.
    // payment.validateCard() — ошибка компиляции.

    private void validateCard() {
        // В реальности: проверка токена через платёжный шлюз,
        // проверка срока действия, Luhn-алгоритм для номера карты.
        if (cardToken.isBlank()) {
            throw new IllegalStateException("Invalid card token");
        }
    }

    private void connectToGateway() {
        // В реальности: HTTP-вызов к Stripe/PayPal,
        // retry-логика, timeout, circuit breaker.
    }

    // --- Геттеры ---
    public String getPaymentId() { return paymentId; }
    public BigDecimal getAmount() { return amount; }
    public String getOrderId() { return orderId; }
    public Status getStatus() { return status; }
    public Instant getCreatedAt() { return createdAt; }
    public Instant getUpdatedAt() { return updatedAt; }

    // ОБРАТИТЕ ВНИМАНИЕ: геттера для cardToken НЕТ.
    // Это осознанное решение: токен карты — внутренняя деталь.

    /**
     * toString() — БЕЗОПАСНЫЙ. Не выводит cardToken.
     *
     * Логи часто попадают в ELK, Splunk, CloudWatch.
     * Данные карт в логах = нарушение PCI DSS и здравого смысла.
     */
    @Override
    public String toString() {
        return String.format(
            "Payment{id='%s', orderId='%s', amount=%s, status=%s}",
            paymentId, orderId, amount, status
        );
    }
}
```

#### Таблица модификаторов доступа

|Модификатор|Свой класс|Свой пакет|Подклассы|Весь мир|
|---|---|---|---|---|
|`private`|✅|❌|❌|❌|
|_(default)_|✅|✅|❌|❌|
|`protected`|✅|✅|✅|❌|
|`public`|✅|✅|✅|✅|

Примеры из нашего домена:

- **`private`**: `cardToken` — только `Payment` знает о нём
- **`(default)`**: вспомогательный класс `OrderValidator`, используемый только внутри пакета
- **`protected`**: метод `executeTransaction()` — подклассы переопределяют (раздел 3)
- **`public`**: `order.cancel()` — вызывается из контроллеров, сервисов, тестов

---

### 2.3 Under the Hood

В памяти JVM **нет разницы** между `private` и `public` полями. Они занимают одинаковое количество байт, расположены в одном и том же объекте. Разница — в **access flags**: метаданных в байткоде, которые проверяются:

1. **Компилятором** (`javac`) — при компиляции
2. **Верификатором байткода** — при загрузке класса

```java
package com.ecommerce.analysis;

/**
 * Инкапсуляция — это контракт, а не физическая защита памяти.
 */
public class EncapsulationInternals {

    private int secret = 42;
    public int open = 100;

    // В байткоде:
    // secret → access_flags = ACC_PRIVATE
    // open   → access_flags = ACC_PUBLIC
    //
    // В памяти объекта: оба — по 4 байта int.
    // access_flags хранятся в метаданных класса (Metaspace), не в объекте.

    public static void main(String[] args) throws Exception {
        EncapsulationInternals obj = new EncapsulationInternals();

        // Обычный доступ к private полю:
        // obj.secret = 99;  // Ошибка компиляции!

        // Через Reflection — можно обойти проверку:
        var field = EncapsulationInternals.class.getDeclaredField("secret");
        field.setAccessible(true);  // «Отключаем» проверку доступа
        field.setInt(obj, 99);
        System.out.println("Via reflection: " + field.getInt(obj)); // 99

        // Но! С Java 9+ модульная система (JPMS) может запретить setAccessible:
        // если модуль не "opens" пакет → InaccessibleObjectException.
        //
        // ВЫВОД: инкапсуляция — контракт между разработчиками.
        // Reflection может его обойти, но это считается нарушением контракта
        // и в современной Java всё сильнее ограничивается.
    }
}
```

---

### 2.4 Production Grade: record как DTO

```java
package com.ecommerce.model;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;

/**
 * Квитанция об оплате — неизменяемый DTO (Data Transfer Object).
 *
 * record (Java 16+) — удобный способ создать класс-контейнер для данных:
 * - Все поля автоматически private и final
 * - Генерируются accessor-методы (paymentId(), amount(), ...)
 * - Генерируются equals(), hashCode(), toString()
 * - Класс автоматически final — нельзя наследоваться
 *
 * ОГРАНИЧЕНИЕ: record обеспечивает только SHALLOW immutability.
 * Ссылка на список — final, но содержимое списка может быть изменяемым,
 * если не сделать защитную копию. Поэтому ниже мы используем List.copyOf().
 */
public record PaymentReceipt(
        String paymentId,
        BigDecimal amount,
        Instant timestamp,
        List<String> itemIds
) {
    // Compact конструктор — специальный синтаксис для record.
    // Вызывается при каждом создании. Здесь валидируем и делаем defensive copy.
    public PaymentReceipt {
        if (paymentId == null || paymentId.isBlank()) {
            throw new IllegalArgumentException("Payment ID required");
        }
        if (amount == null) {
            throw new IllegalArgumentException("Amount required");
        }
        if (timestamp == null) {
            throw new IllegalArgumentException("Timestamp required");
        }
        if (itemIds == null) {
            throw new IllegalArgumentException("Item IDs required");
        }

        // List.copyOf() создаёт НЕИЗМЕНЯЕМУЮ копию.
        // Это защищает от двух проблем:
        // 1. Внешний код изменит исходный список после создания receipt
        // 2. Получатель receipt попытается изменить список
        //
        // Если элементы списка — мутабельные объекты (не наш случай: String immutable),
        // то List.copyOf защитит только список, но не элементы. Для глубокой защиты
        // нужно копировать и элементы.
        itemIds = List.copyOf(itemIds);
    }
}
```

---

### 2.5 Edge Cases

```java
package com.ecommerce.edgecases;

import com.ecommerce.model.LineItem;
import com.ecommerce.model.Order;

import java.math.BigDecimal;
import java.util.List;

public class EncapsulationEdgeCases {

    public static void main(String[] args) {

        // --- 1. Утечка изменяемой ссылки через геттер ---
        //
        // ПЛОХОЙ геттер (НЕ делайте так!):
        //   public List<LineItem> getItems() {
        //       return items;  // Прямая ссылка на внутренний список!
        //   }
        //
        // Тогда внешний код может:
        //   order.getItems().clear();     // Удалить все товары
        //   order.getItems().add(fake);   // Добавить фейковый товар
        //
        // ПРАВИЛЬНО: return Collections.unmodifiableList(items)

        Order order = new Order("ORD-001", List.of(
            new LineItem("SKU-001", 1, new BigDecimal("10.00"))
        ));

        try {
            order.getItems().clear();  // UnsupportedOperationException!
        } catch (UnsupportedOperationException e) {
            System.out.println("List is protected: " + e.getClass().getSimpleName());
        }

        // --- 2. toString() с чувствительными данными ---
        //
        // toString() вызывается ВЕЗДЕ:
        //   log.info("Processing: {}", payment);   // SLF4J вызовет toString()
        //   throw new RuntimeException("Error: " + payment);  // конкатенация
        //   IDE отладчик                            // toString() для отображения
        //
        // Если toString() содержит номер карты → он попадёт в логи,
        // которые читают десятки людей. Это нарушение PCI DSS.

        // --- 3. Сериализация может обходить инкапсуляцию ---
        //
        // Jackson (JSON-библиотека) может читать private поля через reflection
        // или через геттеры: getCardToken() → JSON поле "cardToken".
        //
        // Решения:
        // - @JsonIgnore на чувствительных полях/геттерах
        // - @JsonProperty(access = Access.WRITE_ONLY) — только десериализация
        // - Отдельный DTO (record) для API, содержащий только нужные поля
    }
}
```

---

## 3. Наследование

### 3.1 Концепт

В интернет-магазине нужно отправлять уведомления. Каждое имеет общие черты: получатель, текст, время. Но способ доставки отличается:

- **EmailNotification** — тема письма, HTML-тело
- **SmsNotification** — номер телефона, лимит на длину
- **PushNotification** — device token, deep link

Наследование описывает отношение **«является разновидностью» (is-a)**:

|Утверждение|Верно?|Тип связи|
|---|---|---|
|EmailNotification **является** Notification|✅|Наследование (is-a)|
|Order **содержит** Payment|❌|Композиция (has-a)|

> **Правило:** Если не можете честно сказать «A является разновидностью B» — не используйте наследование. Используйте композицию (поле внутри класса) или интерфейсы.

---

### 3.2 Hello World

#### Базовый класс

```java
package com.ecommerce.notification;

import java.time.Instant;

/**
 * Базовый класс уведомления.
 *
 * abstract — от этого класса НЕЛЬЗЯ создать экземпляр:
 *   new Notification(...) → ошибка компиляции!
 *
 * Можно создавать только конкретные подклассы:
 *   new EmailNotification(...)  → OK
 *   new SmsNotification(...)    → OK
 *
 * Зачем abstract? Потому что «просто уведомление» не имеет смысла —
 * нужно знать КАК его отправить (email? SMS? push?).
 */
public abstract class Notification {

    // Поля — private. Подклассы получают доступ через геттеры.
    private final String userId;
    private final String message;
    private final Instant createdAt;

    /**
     * Конструктор базового класса.
     *
     * protected — подклассы могут вызвать через super(...),
     * но внешний код не может вызвать напрямую.
     *
     * Подклассы ОБЯЗАНЫ вызвать super(...) первой строкой своего конструктора.
     */
    protected Notification(String userId, String message) {
        if (userId == null || userId.isBlank()) {
            throw new IllegalArgumentException("User ID must not be null or blank");
        }
        if (message == null || message.isBlank()) {
            throw new IllegalArgumentException("Message must not be null or blank");
        }

        this.userId = userId;
        this.message = message;
        this.createdAt = Instant.now();
    }

    /**
     * Отправляет уведомление.
     *
     * abstract — НЕ имеет тела. Каждый подкласс обязан реализовать.
     *
     * Контракт: «Любое уведомление умеет себя отправлять,
     * но КАК — зависит от конкретного типа.»
     */
    public abstract boolean send();

    /**
     * Форматирует сообщение для логов.
     *
     * НЕ abstract — имеет реализацию по умолчанию.
     * Подклассы могут переопределить, если нужно другое форматирование.
     */
    public String formatForLog() {
        String preview = message.length() > 50
            ? message.substring(0, 50) + "..."
            : message;
        return String.format("[%s] To user %s: %s",
            this.getClass().getSimpleName(), userId, preview);
    }

    // Геттеры — public, доступны подклассам и внешнему коду
    public String getUserId() { return userId; }
    public String getMessage() { return message; }
    public Instant getCreatedAt() { return createdAt; }
}
```

#### Подклассы

```java
package com.ecommerce.notification;

/**
 * Email-уведомление.
 *
 * extends Notification — наследует поля и методы Notification.
 * Добавляет свои поля (subject, htmlBody) и реализует send().
 */
public class EmailNotification extends Notification {

    private final String subject;
    private final String htmlBody;

    public EmailNotification(String userId, String message,
                              String subject, String htmlBody) {
        // super(...) — вызов конструктора родителя.
        // ОБЯЗАН быть ПЕРВОЙ строкой конструктора.
        super(userId, message);

        if (subject == null || subject.isBlank()) {
            throw new IllegalArgumentException("Subject must not be null or blank");
        }
        if (htmlBody == null || htmlBody.isBlank()) {
            throw new IllegalArgumentException("HTML body must not be null or blank");
        }

        this.subject = subject;
        this.htmlBody = htmlBody;
    }

    /**
     * Реализация абстрактного метода send().
     *
     * @Override — ОБЯЗАТЕЛЬНАЯ аннотация. Без неё:
     * 1. Если в Notification переименуют send() → наш метод
     *    перестанет быть переопределением. С @Override компилятор поймает.
     * 2. Читатель сразу видит: это переопределение, не новый метод.
     */
    @Override
    public boolean send() {
        // В реальности: SMTP, SendGrid, AWS SES
        System.out.printf("📧 Email to %s: Subject '%s'%n", getUserId(), subject);
        return true;
    }

    @Override
    public String formatForLog() {
        // super.formatForLog() — вызов метода родительского класса
        return super.formatForLog() + " [Subject: " + subject + "]";
    }

    public String getSubject() { return subject; }
    public String getHtmlBody() { return htmlBody; }
}
```

```java
package com.ecommerce.notification;

/**
 * SMS-уведомление.
 *
 * Отличие от email: ограничение на длину сообщения.
 * Примечание: реальный лимит SMS зависит от кодировки
 * (160 символов для GSM-7, 70 для Unicode). Здесь упрощаем.
 */
public class SmsNotification extends Notification {

    private static final int MAX_SMS_LENGTH = 160;
    private final String phoneNumber;

    public SmsNotification(String userId, String message, String phoneNumber) {
        super(userId, message);

        if (phoneNumber == null || phoneNumber.isBlank()) {
            throw new IllegalArgumentException("Phone number must not be null or blank");
        }
        if (message.length() > MAX_SMS_LENGTH) {
            throw new IllegalArgumentException(
                "SMS too long: " + message.length() + " chars (max " + MAX_SMS_LENGTH + ")"
            );
        }

        this.phoneNumber = phoneNumber;
    }

    @Override
    public boolean send() {
        // В реальности: Twilio, AWS SNS
        System.out.printf("📱 SMS to %s: %s%n", phoneNumber, getMessage());
        return true;
    }

    public String getPhoneNumber() { return phoneNumber; }
}
```

#### Использование — полиморфизм в действии

```java
package com.ecommerce.notification;

import java.util.List;

public class NotificationDemo {

    public static void main(String[] args) {
        // Тип переменной — Notification (базовый класс),
        // реальные объекты — EmailNotification и SmsNotification
        List<Notification> notifications = List.of(
            new EmailNotification(
                "user-123",
                "Your order has been shipped!",
                "Order Shipped - #ORD-001",
                "<h1>Your order is on its way!</h1>"
            ),
            new SmsNotification(
                "user-456",
                "Order #ORD-002 confirmed. Track: bit.ly/track002",
                "+1-555-0123"
            )
        );

        // Единый цикл — один и тот же код для ЛЮБОГО типа уведомления.
        // JVM в runtime определяет, какую реализацию send() вызвать.
        // Это и есть полиморфизм.
        for (Notification n : notifications) {
            n.send();
            System.out.println("  Log: " + n.formatForLog());
        }
    }
}
```

Вывод:

```text
📧 Email to user-123: Subject 'Order Shipped - #ORD-001'
  Log: [EmailNotification] To user user-123: Your order has been shipped! [Subject: Order Shipped - #ORD-001]
📱 SMS to +1-555-0123: Order #ORD-002 confirmed. Track: bit.ly/track002
  Log: [SmsNotification] To user user-456: Order #ORD-002 confirmed. Track: bit.ly/track002
```

---

### 3.3 Under the Hood: наследование в памяти

Когда мы создаём `new EmailNotification(...)`, в куче появляется **один объект**, который содержит поля **всех классов** в иерархии:

```text
┌──────────────────────────────────────────────────────┐
│ Object Header                                        │
│   Klass Pointer ────► EmailNotification              │  ← НЕ Notification!
├──────────────────────────────────────────────────────┤
│ Поля Notification (базовый класс):                   │
│   userId     → String                                │
│   message    → String                                │
│   createdAt  → Instant                               │
├──────────────────────────────────────────────────────┤
│ Поля EmailNotification (подкласс):                   │
│   subject    → String                                │
│   htmlBody   → String                                │
└──────────────────────────────────────────────────────┘
```

Klass Pointer указывает на **EmailNotification**, не на Notification. По этому указателю JVM находит таблицу виртуальных методов (vtable) и определяет, какую реализацию `send()` вызвать.

> **Примечание:** Конкретная раскладка полей, их порядок и размеры зависят от JVM. JVM может переупорядочить поля для оптимального выравнивания. Используйте JOL для проверки на конкретной платформе.

#### Цепочка инициализации


```java
new EmailNotification(...)
  ↓
  EmailNotification.<init>()
    → super(userId, message)         // первая строка
      ↓
      Notification.<init>()
        → super()                    // неявно
          ↓
          Object.<init>()            // вершина иерархии
          ← return
        ← userId, message, createdAt инициализированы
      ← return
    ← subject, htmlBody инициализированы
  ← return
```

Порядок всегда **сверху вниз**: от `Object` к самому конкретному подклассу. Это гарантирует, что поля базового класса инициализированы **до того**, как подкласс начнёт с ними работать.

---

### 3.4 Production Grade: Template Method

```java
package com.ecommerce.payment;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;

/**
 * Абстрактный процессор платежей — пример паттерна Template Method.
 *
 * Базовый класс определяет СКЕЛЕТ алгоритма:
 * 1. validate()           — общая логика (private)
 * 2. executeTransaction() — абстрактный (каждый подкласс свой)
 * 3. logResult()          — общая логика (private)
 *
 * Почему это оправданное использование наследования:
 * - Иерархия мелкая (1 уровень)
 * - Подклассы реализуют только то, что действительно отличается
 * - Базовый класс контролирует порядок шагов
 */
public abstract class AbstractPaymentProcessor {

    // static final — один логгер на класс, НЕ на экземпляр.
    // Подклассы должны объявлять свой собственный логгер.
    private static final Logger log = LoggerFactory.getLogger(AbstractPaymentProcessor.class);

    /**
     * Обрабатывает платёж — Template Method.
     *
     * final — подклассы НЕ МОГУТ переопределить. Порядок шагов фиксирован.
     */
    public final PaymentResult process(String orderId, BigDecimal amount) {
        log.info("Processing payment for order {} amount {}", orderId, amount);

        validate(orderId, amount);
        PaymentResult result = executeTransaction(orderId, amount);
        logResult(orderId, result);

        return result;
    }

    /**
     * Валидация — общая для всех процессоров.
     * private — подклассы не видят и не могут переопределить.
     *
     * Если конкретному провайдеру нужна дополнительная валидация
     * (минимальная сумма, поддерживаемые валюты), он может проверять
     * это внутри своего executeTransaction().
     */
    private void validate(String orderId, BigDecimal amount) {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID is required");
        }
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive: " + amount);
        }
    }

    /**
     * Выполнение транзакции — каждый подкласс реализует сам.
     *
     * protected — доступен подклассам, но не внешнему коду.
     * abstract — реализация обязательна.
     */
    protected abstract PaymentResult executeTransaction(String orderId, BigDecimal amount);

    private void logResult(String orderId, PaymentResult result) {
        if (result.success()) {
            log.info("Payment OK for order {}: txn={}", orderId, result.transactionId());
        } else {
            log.error("Payment FAILED for order {}: {}", orderId, result.errorMessage());
        }
    }
}
```

```java
package com.ecommerce.payment;

/**
 * Результат платежа — неизменяемый DTO.
 */
public record PaymentResult(
        boolean success,
        String transactionId,
        String errorMessage
) {
    /** Фабричный метод: успешный результат. */
    public static PaymentResult success(String transactionId) {
        return new PaymentResult(true, transactionId, null);
    }

    /** Фабричный метод: ошибка. */
    public static PaymentResult failure(String errorMessage) {
        return new PaymentResult(false, null, errorMessage);
    }
}
```

```java
package com.ecommerce.payment;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.UUID;

/**
 * Процессор платежей через Stripe.
 *
 * Реализует только executeTransaction().
 * Валидация, логирование, порядок шагов — из базового класса.
 */
public class StripePaymentProcessor extends AbstractPaymentProcessor {

    private static final Logger log = LoggerFactory.getLogger(StripePaymentProcessor.class);

    private final String apiKey;

    public StripePaymentProcessor(String apiKey) {
        if (apiKey == null || apiKey.isBlank()) {
            throw new IllegalArgumentException("API key must not be null or blank");
        }
        this.apiKey = apiKey;
    }

    @Override
    protected PaymentResult executeTransaction(String orderId, BigDecimal amount) {
        try {
            // В реальности:
            // Stripe.apiKey = this.apiKey;
            // Charge charge = Charge.create(Map.of("amount", amount, ...));
            // return PaymentResult.success(charge.getId());

            log.debug("Calling Stripe API for order {}", orderId);
            String txnId = "stripe-" + UUID.randomUUID();
            return PaymentResult.success(txnId);

        } catch (Exception e) {
            log.error("Stripe API error for order {}", orderId, e);
            return PaymentResult.failure("Stripe error: " + e.getMessage());
        }
    }
}
```

---

### 3.5 Edge Cases

#### Вызов переопределяемого метода из конструктора

Это классическая ловушка, которую легко допустить и трудно обнаружить.

```java
package com.ecommerce.edgecases;

/**
 * ПРОБЛЕМА: конструктор базового класса вызывает метод,
 * который подкласс переопределяет. Но подкласс ещё не инициализирован.
 */
public class ConstructorOverrideEdgeCase {

    // --- ПЛОХОЙ КОД (не делайте так!) ---

    static abstract class BadNotification {
        private final String formatted;

        BadNotification(String raw) {
            // ОПАСНО! formatMessage() может быть переопределён подклассом.
            // Но поля подкласса ещё НЕ инициализированы!
            this.formatted = formatMessage(raw);
        }

        protected String formatMessage(String raw) {
            return raw;
        }

        public String getFormatted() { return formatted; }
    }

    static class BadEmailNotification extends BadNotification {
        private final String prefix = "[EMAIL] ";  // инициализируется ПОСЛЕ super()

        BadEmailNotification(String raw) {
            super(raw);
            // Порядок:
            // 1. super(raw) → вызывает formatMessage() → prefix ещё null!
            // 2. prefix = "[EMAIL] " ← только теперь
        }

        @Override
        protected String formatMessage(String raw) {
            // prefix здесь = null!
            return prefix + raw;  // "null" + "Hello" = "nullHello"
        }
    }

    // --- ПРАВИЛЬНЫЙ КОД ---

    static abstract class GoodNotification {
        private final String raw;

        GoodNotification(String raw) {
            this.raw = raw;  // Конструктор только СОХРАНЯЕТ данные
        }

        // Форматирование — ПОСЛЕ полной инициализации объекта
        public String getFormatted() {
            return formatMessage(raw);
        }

        protected abstract String formatMessage(String raw);
    }

    public static void main(String[] args) {
        BadEmailNotification bad = new BadEmailNotification("Hello");
        System.out.println(bad.getFormatted());
        // "nullHello" — prefix был null при вызове formatMessage

        System.out.println();
        System.out.println("Правило: НИКОГДА не вызывайте переопределяемые методы");
        System.out.println("из конструктора. Поля подкласса ещё не инициализированы.");
    }
}
```

#### Проблема с `equals()` в иерархии наследования

```java
package com.ecommerce.edgecases;

/**
 * Если equals() использует instanceof, объекты разных подклассов
 * могут оказаться «равны» друг другу. Иногда это желаемое поведение,
 * иногда — баг. Важно принять осознанное решение.
 */
public class EqualsInHierarchyEdgeCase {

    static class User {
        private final String email;

        User(String email) { this.email = email; }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof User user)) return false;
            return email.equals(user.email);
        }

        @Override
        public int hashCode() { return email.hashCode(); }
    }

    static class AdminUser extends User {
        private final String adminLevel;

        AdminUser(String email, String adminLevel) {
            super(email);
            this.adminLevel = adminLevel;
        }
        // НЕ переопределяет equals()
    }

    public static void main(String[] args) {
        User user = new User("alice@shop.com");
        AdminUser admin = new AdminUser("alice@shop.com", "SUPER_ADMIN");

        System.out.println("user.equals(admin): " + user.equals(admin));  // true
        System.out.println("admin.equals(user): " + admin.equals(user));  // true

        // Это «правильно» или «неправильно»? Зависит от бизнес-логики:
        //
        // Вариант 1: identity по email → instanceof правильный выбор
        //   "Admin — это тот же пользователь, просто с дополнительными правами"
        //
        // Вариант 2: AdminUser и User — разные сущности → используйте getClass():
        //   if (o == null || getClass() != o.getClass()) return false;
        //   Тогда user.equals(admin) → false
        //
        // Вариант 3: сделайте User final — наследование невозможно,
        //   проблема не возникнет
        //
        // Вариант 4: используйте record — автоматически final,
        //   equals сравнивает все компоненты
        //
        // Ключевой вопрос: что означает «равенство» в вашем домене?
        // Ответ на него определяет реализацию equals().
    }
}
```

> **Совет из Effective Java (Joshua Bloch):** «Design and document for inheritance, or else prohibit it.» Если класс не предназначен для наследования — сделайте его `final`. Это защищает от хрупкого наследования и помогает JIT-компилятору выполнять девиртуализацию — замену виртуального вызова на прямой. Разница в производительности зависит от конкретного сценария: для пустых или тривиальных методов может быть заметной, для «тяжёлых» — несущественной. Но главная причина `final` — корректность и ясность дизайна, а не скорость.

# 4. Полиморфизм

---

## 4.1 Концепт

Представьте кассу интернет-магазина. Покупатель нажимает «Оплатить» — и для него процесс всегда одинаков. Но внутри запускается совершенно разная логика в зависимости от способа оплаты:

- **Банковская карта** → связь с банком, авторизация
- **PayPal** → перенаправление, подтверждение
- **Наличные при доставке** → пометить как «ожидает оплату»

Кассе не нужно знать детали каждого способа. Она знает одно: у любого способа оплаты есть операция «принять платёж». Какой именно код выполнится — зависит от конкретного объекта.

**Полиморфизм** — это возможность вызвать метод через общий тип (интерфейс или базовый класс), а JVM в момент выполнения определит, какую именно реализацию запустить, исходя из реального типа объекта.

Это **не** то же самое, что «код не меняется при добавлении нового способа оплаты». Это свойство архитектуры (абстракции, DI, фабрики). Полиморфизм — механизм, который делает такую архитектуру возможной.

---

## 4.2 Hello World

### Интерфейс — контракт

```java
package com.ecommerce.payment;

/**
 * Контракт: любой способ оплаты умеет принять платёж
 * и сообщить своё название.
 *
 * Вызывающий код работает ТОЛЬКО с этим интерфейсом,
 * не зная конкретных реализаций.
 */
public interface PaymentMethod {

    /**
     * Выполнить платёж.
     *
     * @param amount сумма к оплате (положительное число)
     * @return true если платёж успешен, false если отклонён
     */
    boolean pay(double amount);

    /**
     * Название способа оплаты (для чеков и логов).
     */
    String methodName();
}
```

> **Почему `double`, а не `BigDecimal`?** В production-коде для денег используют `BigDecimal` — он считает точно, без ошибок округления (`0.1 + 0.2 == 0.3`, а не `0.30000000000000004`). Но сейчас мы изучаем полиморфизм, а не финансовую арифметику. Чтобы не отвлекаться, используем `double`. В разделе Production Grade переключимся на `BigDecimal`.

### Реализации — каждая со своим поведением

```java
package com.ecommerce.payment;

/**
 * Оплата банковской картой.
 */
public class CreditCardPayment implements PaymentMethod {

    private final String cardholderName;

    public CreditCardPayment(String cardholderName) {
        if (cardholderName == null || cardholderName.isBlank()) {
            throw new IllegalArgumentException("Cardholder name required");
        }
        this.cardholderName = cardholderName;
    }

    @Override
    public boolean pay(double amount) {
        // В реальности: вызов Stripe API, авторизация, 3D Secure
        System.out.println("💳 Card payment: $" + amount
            + " (cardholder: " + cardholderName + ")");
        System.out.println("   → Authorized ✅");
        return true;
    }

    @Override
    public String methodName() {
        return "Credit Card";
    }
}
```

```java
package com.ecommerce.payment;

/**
 * Оплата через PayPal.
 */
public class PayPalPayment implements PaymentMethod {

    private final String email;

    public PayPalPayment(String email) {
        if (email == null || email.isBlank()) {
            throw new IllegalArgumentException("PayPal email required");
        }
        this.email = email;
    }

    @Override
    public boolean pay(double amount) {
        // В реальности: redirect, OAuth, webhook
        System.out.println("🅿️ PayPal payment: $" + amount);
        System.out.println("   → Confirmed ✅");
        return true;
    }

    @Override
    public String methodName() {
        return "PayPal";
    }
}
```

```java
package com.ecommerce.payment;

/**
 * Оплата наличными при доставке.
 */
public class CashOnDeliveryPayment implements PaymentMethod {

    @Override
    public boolean pay(double amount) {
        System.out.println("💵 Cash on delivery: $" + amount);
        System.out.println("   → Will be collected at delivery");
        return true;
    }

    @Override
    public String methodName() {
        return "Cash on Delivery";
    }
}
```

### Полиморфизм в действии

```java
package com.ecommerce.payment;

/**
 * Сервис оформления заказа.
 *
 * Метод checkout() принимает PaymentMethod — ИНТЕРФЕЙС.
 * Он не знает, какая реализация придёт.
 * Он вызывает pay(), и JVM в runtime определяет,
 * какой именно код выполнить.
 */
public class CheckoutService {

    public void checkout(String orderId, double total, PaymentMethod method) {
        System.out.println("=== Checkout: order " + orderId + " ===");
        System.out.println("Total: $" + total);
        System.out.println("Method: " + method.methodName());
        System.out.println();

        // ПОЛИМОРФНЫЙ ВЫЗОВ:
        // JVM смотрит на РЕАЛЬНЫЙ тип объекта method
        // и вызывает ЕГО версию pay()
        boolean success = method.pay(total);

        System.out.println();
        if (success) {
            System.out.println("✅ Order " + orderId + " — payment accepted");
        } else {
            System.out.println("❌ Order " + orderId + " — payment declined");
        }
        System.out.println();
    }

    public static void main(String[] args) {
        CheckoutService service = new CheckoutService();
        double total = 99.99;

        // Один и тот же метод checkout() — три разных поведения:

        service.checkout("ORD-001", total,
            new CreditCardPayment("Alice Smith"));

        service.checkout("ORD-002", total,
            new PayPalPayment("alice@example.com"));

        service.checkout("ORD-003", total,
            new CashOnDeliveryPayment());

        // checkout() НЕ МЕНЯЛСЯ.
        // Добавить Apple Pay = создать ApplePayPayment implements PaymentMethod.
        // Но где-то нужно решить, КАКУЮ реализацию передать —
        // это задача фабрики, конфигурации или DI-контейнера.
    }
}
```

### Compile-time vs Runtime полиморфизм

В Java есть два механизма, которые иногда оба называют «полиморфизмом». Это разные вещи, и важно не путать их:

```java
package com.ecommerce.payment;

/**
 * Перегрузка (overloading) vs Переопределение (overriding).
 */
public class PolymorphismTypesDemo {

    // ═══════════════════════════════════════════════════════
    // ПЕРЕГРУЗКА (Overloading) — compile-time
    // Компилятор выбирает метод по типам АРГУМЕНТОВ.
    // Это разные методы с одним именем.
    // ═══════════════════════════════════════════════════════

    // Вариант 1: скидка в процентах
    static double applyDiscount(double price, double percentage) {
        System.out.println("  [перегрузка 1] Скидка " + percentage + "%");
        return price * (1 - percentage / 100);
    }

    // Вариант 2: скидка по промокоду (фиксированная сумма)
    static double applyDiscount(double price, String promoCode) {
        System.out.println("  [перегрузка 2] Промокод: " + promoCode);
        double discount = 10.0; // упрощённо
        // Не уходим в минус
        return Math.max(0, price - discount);
    }

    // ═══════════════════════════════════════════════════════
    // ПЕРЕОПРЕДЕЛЕНИЕ (Overriding) — runtime
    // JVM выбирает метод по РЕАЛЬНОМУ ТИПУ объекта.
    // Одна сигнатура — разные реализации в иерархии.
    // Это и есть «настоящий» полиморфизм в ООП.
    // ═══════════════════════════════════════════════════════
    // (Уже показан выше: PaymentMethod.pay() →
    //  CreditCardPayment / PayPalPayment / CashOnDelivery)

    public static void main(String[] args) {
        double price = 100.0;

        System.out.println("=== Перегрузка (compile-time) ===");
        // Компилятор ВИДИТ тип второго аргумента и выбирает метод:
        double r1 = applyDiscount(price, 15.0);         // → вариант 1 (double)
        System.out.println("  Результат: " + r1);

        double r2 = applyDiscount(price, "SUMMER2024");  // → вариант 2 (String)
        System.out.println("  Результат: " + r2);

        System.out.println();
        System.out.println("=== Переопределение (runtime) ===");

        // Тип ссылки: PaymentMethod
        // Тип объекта: разный каждый раз
        PaymentMethod[] methods = {
            new CreditCardPayment("Alice"),
            new PayPalPayment("alice@mail.com"),
            new CashOnDeliveryPayment()
        };

        for (PaymentMethod m : methods) {
            System.out.println("--- " + m.methodName() + " ---");
            // JVM смотрит на реальный тип и вызывает его pay()
            m.pay(49.99);
            System.out.println();
        }

        System.out.println("=== Разница ===");
        System.out.println("Перегрузка:      компилятор выбирает метод → статически");
        System.out.println("Переопределение: JVM выбирает метод → динамически (runtime)");
    }
}
```

> **Примечание о терминологии.** Перегрузку (overloading) иногда называют «статическим полиморфизмом», но это натяжка. В ООП под полиморфизмом обычно понимают именно **subtype polymorphism** — динамический диспетч через переопределение (overriding). Есть ещё **параметрический полиморфизм** (generics) — это третий вид, о нём отдельная тема.

> **Совет:** Не перегружайте методы в интерфейсах без крайней необходимости. Перегрузка разрешается по типу **ссылки** (compile-time), а переопределение — по типу **объекта** (runtime). Их комбинация запутывает. Лучше дать методам разные имена: `applyPercentageDiscount(...)`, `applyPromoCode(...)`.

---

## 4.3 Under the Hood: как JVM выбирает метод

Когда вы пишете `method.pay(amount)`, а `method` объявлена как `PaymentMethod` (интерфейс), компилятор не знает, какую реализацию вызвать. Он генерирует **инструкцию байткода**, а JVM разбирается в runtime.

### Пять invoke-инструкций

В байткоде JVM есть пять видов вызова метода:

|Инструкция|Когда используется|Пример|Dispatch|
|---|---|---|---|
|`invokeinterface`|Вызов через интерфейс|`PaymentMethod.pay()`|Поиск по itable|
|`invokevirtual`|Вызов через класс|`CreditCardPayment.pay()`|Поиск по vtable|
|`invokestatic`|Статический метод|`Math.max()`|Прямой вызов|
|`invokespecial`|Конструктор, `super`, private|`new CreditCardPayment()`|Прямой вызов|
|`invokedynamic`|Лямбды, строковая конкатенация|`() -> x.pay(100)`|Bootstrap + CallSite|

Посмотреть байткод можно командой `javap -c -v MyClass.class` (скомпилировав из корня проекта с правильной структурой пакетов).

### vtable и itable — таблицы методов

Каждый класс в JVM имеет **vtable** (virtual method table) — массив указателей на реализации методов. Когда JVM выполняет `invokevirtual`, она:

1. Берёт объект из стека операндов
2. По заголовку объекта находит его класс (Klass Pointer → Metaspace)
3. В vtable класса по фиксированному индексу находит нужный метод
4. Вызывает его

Это **O(1)** — один переход по индексу.

Для **интерфейсов** сложнее: класс может реализовывать много интерфейсов, и у каждого свои методы. JVM поддерживает **itable** — таблицу, где для каждого реализованного интерфейса хранятся указатели на методы. При `invokeinterface` JVM ищет нужный интерфейс в itable — это может быть чуть дороже, чем vtable.

> **На практике** разница между `invokeinterface` и `invokevirtual` после JIT-компиляции часто исчезает — благодаря inline caches (см. ниже). Не выбирайте между классом и интерфейсом ради «производительности dispatch». Выбирайте по смыслу дизайна.

### Inline Caches — почему полиморфизм быстрый

JIT-компилятор не выполняет полный поиск по таблице каждый раз. Он запоминает, какой тип объекта реально приходил на конкретный вызов (call-site), и оптимизирует:

**Monomorphic** (один тип) — лучший случай. На этот call-site всегда приходит, например, `CreditCardPayment`. JIT вставляет быструю проверку типа и прямой вызов (или даже встраивает код метода целиком — inlining).

**Bimorphic** (два типа) — JIT делает две проверки. Всё ещё быстро.

**Megamorphic** (много типов) — JIT не может оптимизировать, откатывается к полному поиску по таблице. Это медленнее, но в абсолютных числах — десятки наносекунд. Для сравнения: один запрос к базе данных — миллисекунды (в тысячи раз дольше).

> **Вывод:** В обычном backend-коде стоимость виртуального вызова **незаметна** на фоне сети, БД, сериализации. Megamorphic call-site может стать проблемой только в tight loops, обрабатывающих миллионы элементов в памяти. И даже тогда — сначала измеряйте (JMH, async-profiler), потом оптимизируйте.

### Де-виртуализация

Иногда JIT **полностью убирает** виртуальный вызов:

- **`final` класс или метод** — нет подклассов, значит реализация единственная. Прямой вызов.
- **`sealed` интерфейс** (Java 17+) — все реализации известны. JIT может оптимизировать.
- **Class Hierarchy Analysis (CHA)** — если загружена только одна реализация интерфейса, JIT де-виртуализирует вызов. Если позже загрузится вторая — JIT выполнит деоптимизацию и перекомпилирует.
- **Escape Analysis** — если объект создаётся и используется только внутри метода (не «убегает»), JIT может устранить аллокацию и встроить код.

```java
// final класс → JIT гарантированно де-виртуализирует
public final class FastCardPayment implements PaymentMethod {

    private final String name;

    public FastCardPayment(String name) { this.name = name; }

    @Override
    public boolean pay(double amount) {
        // JIT может встроить этот код в вызывающий метод
        return amount > 0;
    }

    @Override
    public String methodName() { return "Fast Card"; }
}
```

> **Как проверить.** Запустите JVM с флагами `-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining -XX:+PrintCompilation`. В выводе строка вроде `@ 5 FastCardPayment::pay (8 bytes) inline (hot)` означает: JIT встроил метод, виртуального вызова нет. Для production используйте JFR (Java Flight Recorder) — он анализирует без заметного влияния на производительность.

---

## 4.4 Production Grade: паттерн Strategy

Полиморфизм — механизм. **Strategy** — паттерн, который его использует. Идея: вынести изменяемое поведение в отдельный интерфейс и подставлять нужную реализацию.

**Задача:** в интернет-магазине действуют разные скидки — процентная, по промокоду, по уровню лояльности, или никакой. Вместо каскада `if-else` создаём интерфейс и реализации.

### Интерфейс

```java
package com.ecommerce.pricing;

import java.math.BigDecimal;

/**
 * Контракт для стратегии скидок.
 *
 * Каждая реализация знает свою логику расчёта.
 * Вызывающий код работает только с этим интерфейсом.
 */
public interface DiscountStrategy {

    /**
     * Рассчитывает сумму после скидки.
     *
     * @param originalPrice исходная сумма (не null, положительная)
     * @return сумма после скидки (>= 0)
     * @throws NullPointerException если originalPrice == null
     */
    BigDecimal applyDiscount(BigDecimal originalPrice);

    /**
     * Название стратегии — для логов и аудита.
     */
    String strategyName();
}
```

### Реализации

```java
package com.ecommerce.pricing;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

/**
 * Никакой скидки — возвращает полную цену.
 *
 * Используется как fallback, чтобы не проверять null.
 * Это применение паттерна Null Object.
 */
public final class NoDiscount implements DiscountStrategy {

    @Override
    public BigDecimal applyDiscount(BigDecimal originalPrice) {
        Objects.requireNonNull(originalPrice, "Price must not be null");
        return originalPrice;
    }

    @Override
    public String strategyName() {
        return "No Discount";
    }
}
```

```java
package com.ecommerce.pricing;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

/**
 * Скидка в процентах. Например, 15% на весь заказ.
 */
public final class PercentageDiscount implements DiscountStrategy {

    private final BigDecimal percentage;

    /**
     * @param percentage процент скидки (от 0 до 100 включительно)
     */
    public PercentageDiscount(BigDecimal percentage) {
        Objects.requireNonNull(percentage, "Percentage must not be null");

        if (percentage.compareTo(BigDecimal.ZERO) < 0
                || percentage.compareTo(new BigDecimal("100")) > 0) {
            throw new IllegalArgumentException(
                "Percentage must be 0–100, got: " + percentage);
        }
        this.percentage = percentage;
    }

    @Override
    public BigDecimal applyDiscount(BigDecimal originalPrice) {
        Objects.requireNonNull(originalPrice, "Price must not be null");

        // total * (1 - percentage / 100)
        BigDecimal multiplier = BigDecimal.ONE.subtract(
            percentage.divide(new BigDecimal("100"), 4, RoundingMode.HALF_EVEN)
        );

        return originalPrice.multiply(multiplier)
            .setScale(2, RoundingMode.HALF_EVEN);
    }

    @Override
    public String strategyName() {
        return "Percentage Discount (" + percentage + "%)";
    }
}
```

> **Почему `HALF_EVEN`, а не `HALF_UP`?** `HALF_EVEN` (banker's rounding) — стандартное округление в финансах. При значении ровно на границе (например, 2.5) оно округляет к ближайшему чётному (2, а не 3). Это уменьшает статистическое смещение при большом объёме транзакций. `HALF_UP` — «школьное» округление (2.5 → 3), оно подходит для бытовых расчётов, но в финансовых системах предпочитают `HALF_EVEN`.


```java
package com.ecommerce.pricing;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

/**
 * Фиксированная скидка по промокоду.
 *
 * Инвариант: результат никогда не отрицательный.
 * Если скидка больше цены — возвращаем 0.
 */
public final class PromoCodeDiscount implements DiscountStrategy {

    private final String promoCode;
    private final BigDecimal fixedAmount;

    public PromoCodeDiscount(String promoCode, BigDecimal fixedAmount) {
        if (promoCode == null || promoCode.isBlank()) {
            throw new IllegalArgumentException("Promo code must not be blank");
        }
        Objects.requireNonNull(fixedAmount, "Fixed amount must not be null");

        if (fixedAmount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException(
                "Discount amount must be non-negative, got: " + fixedAmount);
        }

        this.promoCode = promoCode;
        this.fixedAmount = fixedAmount;
    }

    @Override
    public BigDecimal applyDiscount(BigDecimal originalPrice) {
        Objects.requireNonNull(originalPrice, "Price must not be null");

        BigDecimal result = originalPrice.subtract(fixedAmount);
        return result.max(BigDecimal.ZERO)
            .setScale(2, RoundingMode.HALF_EVEN);
    }

    @Override
    public String strategyName() {
        // В production логах промокод может быть коммерчески чувствительным.
        // Здесь показываем для наглядности, но в реальной системе
        // стоит логировать ID акции, а не сам код.
        return "Promo Code (-" + fixedAmount + ")";
    }
}
```

```java
package com.ecommerce.pricing;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.Objects;

/**
 * Скидка по программе лояльности.
 */
public final class LoyaltyDiscount implements DiscountStrategy {

    public enum Tier {
        BRONZE(new BigDecimal("3")),
        SILVER(new BigDecimal("7")),
        GOLD(new BigDecimal("12")),
        PLATINUM(new BigDecimal("20"));

        private final BigDecimal discountPercent;

        Tier(BigDecimal discountPercent) {
            this.discountPercent = discountPercent;
        }

        public BigDecimal getDiscountPercent() { return discountPercent; }
    }

    private final Tier tier;

    public LoyaltyDiscount(Tier tier) {
        this.tier = Objects.requireNonNull(tier, "Tier must not be null");
    }

    @Override
    public BigDecimal applyDiscount(BigDecimal originalPrice) {
        Objects.requireNonNull(originalPrice, "Price must not be null");

        BigDecimal multiplier = BigDecimal.ONE.subtract(
            tier.getDiscountPercent()
                .divide(new BigDecimal("100"), 4, RoundingMode.HALF_EVEN)
        );

        return originalPrice.multiply(multiplier)
            .setScale(2, RoundingMode.HALF_EVEN);
    }

    @Override
    public String strategyName() {
        return "Loyalty (" + tier.name() + " = " + tier.getDiscountPercent() + "%)";
    }
}
```

### Сервис — использование стратегий

```java
package com.ecommerce.pricing;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;

/**
 * Сервис расчёта цен. Использует DiscountStrategy через полиморфизм.
 *
 * НЕ зависит от конкретных реализаций скидок.
 * Стратегии передаются через конструктор (Dependency Injection вручную —
 * никакой магии фреймворков).
 *
 * Все стратегии должны быть stateless и thread-safe:
 * сервис может вызываться из нескольких потоков одновременно.
 */
public class PricingService {

    private final List<DiscountStrategy> availableStrategies;
    private final DiscountStrategy fallback = new NoDiscount();

    /**
     * @param strategies доступные стратегии скидок
     */
    public PricingService(List<DiscountStrategy> strategies) {
        Objects.requireNonNull(strategies, "Strategies must not be null");
        // Defensive copy
        this.availableStrategies = List.copyOf(strategies);
    }

    /**
     * Рассчитывает цену с конкретной стратегией.
     */
    public BigDecimal calculatePrice(BigDecimal originalPrice,
                                      DiscountStrategy strategy) {
        Objects.requireNonNull(originalPrice, "Price must not be null");

        DiscountStrategy effective = (strategy != null) ? strategy : fallback;
        return effective.applyDiscount(originalPrice);
    }

    /**
     * Находит лучшую цену среди всех доступных стратегий.
     */
    public BigDecimal findBestPrice(BigDecimal originalPrice) {
        Objects.requireNonNull(originalPrice, "Price must not be null");

        BigDecimal bestPrice = originalPrice;

        for (DiscountStrategy strategy : availableStrategies) {
            BigDecimal candidate = strategy.applyDiscount(originalPrice);
            if (candidate.compareTo(bestPrice) < 0) {
                bestPrice = candidate;
            }
        }

        return bestPrice;
    }
}
```

### Демонстрация

```java
package com.ecommerce.pricing;

import java.math.BigDecimal;
import java.util.List;

public class PricingDemo {

    public static void main(String[] args) {
        BigDecimal price = new BigDecimal("1000.00");

        // Создаём стратегии
        DiscountStrategy noDiscount = new NoDiscount();
        DiscountStrategy percent15 = new PercentageDiscount(new BigDecimal("15"));
        DiscountStrategy promo = new PromoCodeDiscount("SUMMER2024", new BigDecimal("200"));
        DiscountStrategy loyalty = new LoyaltyDiscount(LoyaltyDiscount.Tier.GOLD);

        // Полиморфизм: один и тот же вызов — разное поведение
        System.out.println("Original price: " + price);
        System.out.println("No discount:    " + noDiscount.applyDiscount(price));
        System.out.println("15% off:        " + percent15.applyDiscount(price));
        System.out.println("Promo -200:     " + promo.applyDiscount(price));
        System.out.println("Gold loyalty:   " + loyalty.applyDiscount(price));

        System.out.println();

        // Сервис выбирает лучшую скидку
        PricingService service = new PricingService(
            List.of(noDiscount, percent15, promo, loyalty)
        );

        BigDecimal best = service.findBestPrice(price);
        System.out.println("Best price:     " + best);
    }
}
```

Вывод:

```text
Original price: 1000.00
No discount:    1000.00
15% off:        850.00
Promo -200:     800.00
Gold loyalty:   880.00

Best price:     800.00
```

### Тесты

```java
package com.ecommerce.pricing;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.params.ParameterizedTest;
import org.junit.jupiter.params.provider.ValueSource;

import java.math.BigDecimal;
import java.util.List;

import static org.junit.jupiter.api.Assertions.*;

class DiscountStrategyTest {

    private final BigDecimal THOUSAND = new BigDecimal("1000.00");

    // ── NoDiscount ──────────────────────────────────

    @Nested
    @DisplayName("NoDiscount")
    class NoDiscountTest {

        @Test
        @DisplayName("returns full price")
        void returnsFullPrice() {
            DiscountStrategy strategy = new NoDiscount();
            BigDecimal result = strategy.applyDiscount(THOUSAND);
            // compareTo игнорирует scale: "1000.00" == "1000"
            assertEquals(0, result.compareTo(THOUSAND));
        }

        @Test
        @DisplayName("rejects null")
        void rejectsNull() {
            assertThrows(NullPointerException.class,
                () -> new NoDiscount().applyDiscount(null));
        }
    }

    // ── PercentageDiscount ──────────────────────────

    @Nested
    @DisplayName("PercentageDiscount")
    class PercentageDiscountTest {

        @Test
        @DisplayName("15% off 1000 = 850")
        void appliesFifteenPercent() {
            DiscountStrategy s = new PercentageDiscount(new BigDecimal("15"));
            BigDecimal result = s.applyDiscount(THOUSAND);
            assertEquals(0, result.compareTo(new BigDecimal("850.00")));
        }

        @Test
        @DisplayName("0% = full price")
        void zeroPercent() {
            DiscountStrategy s = new PercentageDiscount(BigDecimal.ZERO);
            BigDecimal result = s.applyDiscount(THOUSAND);
            assertEquals(0, result.compareTo(THOUSAND));
        }

        @Test
        @DisplayName("100% = zero")
        void hundredPercent() {
            DiscountStrategy s = new PercentageDiscount(new BigDecimal("100"));
            BigDecimal result = s.applyDiscount(THOUSAND);
            assertEquals(0, result.compareTo(BigDecimal.ZERO));
        }

        @ParameterizedTest
        @ValueSource(strings = {"-1", "101", "-0.01", "100.01"})
        @DisplayName("invalid percentage throws")
        void invalidPercentage(String pct) {
            assertThrows(IllegalArgumentException.class,
                () -> new PercentageDiscount(new BigDecimal(pct)));
        }
    }

    // ── PromoCodeDiscount ───────────────────────────

    @Nested
    @DisplayName("PromoCodeDiscount")
    class PromoCodeDiscountTest {

        @Test
        @DisplayName("promo -200 on 1000 = 800")
        void appliesFixedDiscount() {
            DiscountStrategy s = new PromoCodeDiscount("CODE", new BigDecimal("200"));
            BigDecimal result = s.applyDiscount(THOUSAND);
            assertEquals(0, result.compareTo(new BigDecimal("800.00")));
        }

        @Test
        @DisplayName("discount > price → 0, not negative")
        void cannotGoNegative() {
            DiscountStrategy s = new PromoCodeDiscount("BIG", new BigDecimal("9999"));
            BigDecimal result = s.applyDiscount(THOUSAND);
            assertEquals(0, result.compareTo(BigDecimal.ZERO));
        }

        @Test
        @DisplayName("blank promo code throws")
        void blankCode() {
            assertThrows(IllegalArgumentException.class,
                () -> new PromoCodeDiscount("  ", new BigDecimal("100")));
        }
    }

    // ── LoyaltyDiscount ─────────────────────────────

    @Nested
    @DisplayName("LoyaltyDiscount")
    class LoyaltyDiscountTest {

        @Test
        @DisplayName("GOLD (12%) on 1000 = 880")
        void goldDiscount() {
            DiscountStrategy s = new LoyaltyDiscount(LoyaltyDiscount.Tier.GOLD);
            BigDecimal result = s.applyDiscount(THOUSAND);
            assertEquals(0, result.compareTo(new BigDecimal("880.00")));
        }
    }

    // ── PricingService ──────────────────────────────

    @Nested
    @DisplayName("PricingService")
    class PricingServiceTest {

        @Test
        @DisplayName("findBestPrice picks the lowest")
        void findsBest() {
            PricingService service = new PricingService(List.of(
                new NoDiscount(),
                new PercentageDiscount(new BigDecimal("15")),   // 850
                new PromoCodeDiscount("X", new BigDecimal("200")), // 800
                new LoyaltyDiscount(LoyaltyDiscount.Tier.GOLD)   // 880
            ));

            BigDecimal best = service.findBestPrice(THOUSAND);
            assertEquals(0, best.compareTo(new BigDecimal("800.00")));
        }

        @Test
        @DisplayName("null strategy uses fallback (full price)")
        void nullStrategyFallback() {
            PricingService service = new PricingService(List.of());
            BigDecimal result = service.calculatePrice(THOUSAND, null);
            assertEquals(0, result.compareTo(THOUSAND));
        }
    }
}
```

---

## 4.5 Edge Cases

### `instanceof` каскады — запах в коде

Если вы пишете цепочку `if (x instanceof A) ... else if (x instanceof B) ...`, это часто означает, что полиморфизм не используется (или используется не до конца). Каждый новый тип требует изменения этого метода — легко забыть и получить баг.

```java
package com.ecommerce.edgecases;

/**
 * Проблема: instanceof каскад.
 * Решения: полиморфный метод или sealed + switch.
 */
public class InstanceofSmellDemo {

    interface PaymentMethod {
        boolean pay(double amount);
    }

    static class CardPayment implements PaymentMethod {
        private final String network;
        CardPayment(String network) { this.network = network; }
        @Override public boolean pay(double amount) { return true; }
        public String getNetwork() { return network; }
    }

    static class PayPalPayment implements PaymentMethod {
        private final String email;
        PayPalPayment(String email) { this.email = email; }
        @Override public boolean pay(double amount) { return true; }
        public String getEmail() { return email; }
    }

    // ❌ ПЛОХО: каждый новый тип → новая ветка здесь.
    // Забыли добавить → тихий баг.
    static String getDetails_BAD(PaymentMethod p) {
        if (p instanceof CardPayment card) {
            return "Card: " + card.getNetwork();
        } else if (p instanceof PayPalPayment pp) {
            return "PayPal: " + pp.getEmail();
        } else {
            return "Unknown"; // бомба замедленного действия
        }
    }

    // ✅ ЛУЧШЕ: добавить метод в интерфейс.
    // Каждая реализация знает свои детали.
    interface PaymentMethodV2 {
        boolean pay(double amount);
        String getDetails(); // каждая реализация реализует сама
    }

    // ✅ ЕЩЁ ЛУЧШЕ (Java 21): sealed + exhaustive switch.
    // Компилятор гарантирует, что все варианты покрыты.
    // Добавили новый тип → код НЕ скомпилируется, пока не добавите ветку.

    sealed interface PaymentMethodV3
        permits CardV3, PayPalV3 {
        boolean pay(double amount);
    }

    record CardV3(String network) implements PaymentMethodV3 {
        @Override public boolean pay(double amount) { return true; }
    }

    record PayPalV3(String email) implements PaymentMethodV3 {
        @Override public boolean pay(double amount) { return true; }
    }

    static String getDetails_GOOD(PaymentMethodV3 p) {
        return switch (p) {
            case CardV3 card -> "Card: " + card.network();
            case PayPalV3 pp -> "PayPal: " + pp.email();
            // Нет default! Компилятор знает все варианты.
            // Добавь CryptoV3 → ошибка компиляции, пока не добавишь ветку.
        };
    }
}
```

> **Нюанс:** `instanceof` — не абсолютное зло. Он уместен на границах системы: маппинг DTO, сериализация, visitor. `sealed` + pattern matching — это тот же type dispatch, но с гарантией полноты от компилятора. Выбирайте инструмент по ситуации.

### Ковариантность возвращаемого типа

Подкласс может **уточнить** тип возврата переопределённого метода. Это полезно, но с параметрами работает иначе — и это частая ловушка.

```java
package com.ecommerce.edgecases;

/**
 * Return type: подкласс может вернуть более конкретный тип (ковариантность).
 * Parameters: изменение типа параметра — это НЕ override, а overload!
 */
public class CovarianceDemo {

    static class Receipt {
        private final String id;
        Receipt(String id) { this.id = id; }
        public String getId() { return id; }
    }

    static class DetailedReceipt extends Receipt {
        private final String gatewayTxnId;
        DetailedReceipt(String id, String gatewayTxnId) {
            super(id);
            this.gatewayTxnId = gatewayTxnId;
        }
        public String getGatewayTxnId() { return gatewayTxnId; }
    }

    static class BasicProcessor {
        // Возвращает Receipt
        public Receipt process(double amount) {
            return new Receipt("BASIC-001");
        }
    }

    static class AdvancedProcessor extends BasicProcessor {
        // ✅ Ковариантный return type — это override!
        // DetailedReceipt extends Receipt → компилятор разрешает.
        @Override
        public DetailedReceipt process(double amount) {
            return new DetailedReceipt("ADV-001", "GW-TXN-999");
        }
    }

    // ─── Ловушка с параметрами ───

    static class Amount { final double value; Amount(double v) { this.value = v; } }
    static class PreciseAmount extends Amount {
        final int scale;
        PreciseAmount(double v, int s) { super(v); this.scale = s; }
    }

    static class Base {
        public void handle(Amount a) {
            System.out.println("Base.handle(Amount): " + a.value);
        }
    }

    static class Derived extends Base {
        // ⚠️ Это НЕ override, а OVERLOAD!
        // Тип параметра другой: PreciseAmount вместо Amount.
        // @Override  ← раскомментируйте — увидите ошибку компиляции!
        public void handle(PreciseAmount a) {
            System.out.println("Derived.handle(PreciseAmount): " + a.value);
        }
    }

    public static void main(String[] args) {
        // Ковариантный return — работает как ожидается:
        BasicProcessor processor = new AdvancedProcessor();
        Receipt receipt = processor.process(99.99);
        System.out.println("Receipt type: " + receipt.getClass().getSimpleName());
        // → DetailedReceipt (полиморфизм!)

        System.out.println();

        // Ловушка с параметрами:
        Base b = new Derived();
        PreciseAmount precise = new PreciseAmount(50, 4);

        b.handle(precise);
        // → "Base.handle(Amount): 50.0"  (!)
        //
        // Почему? Ссылка типа Base → компилятор ищет handle(Amount).
        // PreciseAmount IS-A Amount → подходит.
        // handle(PreciseAmount) в Derived — это ДРУГОЙ метод (overload),
        // и он не участвует в полиморфном dispatch.

        // Чтобы вызвать handle(PreciseAmount), нужна ссылка типа Derived:
        Derived d = new Derived();
        d.handle(precise);
        // → "Derived.handle(PreciseAmount): 50.0"
    }
}
```

**Правило: всегда ставьте `@Override`.** Если метод не является корректным переопределением, компилятор сразу покажет ошибку. Это спасает от тихих багов, когда вы думаете, что переопределили метод, а на самом деле создали новый.

> Включите в IDE (IntelliJ: Inspections → «Missing @Override») предупреждение об отсутствующем `@Override`. Также добавьте в Checkstyle или Error Prone правило `MissingOverride`. Ошибки лучше ловить при компиляции, а не в production в три часа ночи

# 5. Абстрактные классы и интерфейсы

---

## 5.1 Концепт

**Интерфейс — это контракт.**

Представьте, что вы — владелец интернет-магазина и подключаете платёжного провайдера. Вам неважно, как он устроен внутри. Вам важен контракт:

- `authorize(amount)` — заблокировать сумму
- `capture(transactionId)` — списать деньги
- `refund(transactionId)` — вернуть деньги

Stripe, PayPal, Тинькофф — неважно. Контракт одинаковый. Любой, кто его выполняет, может быть подключён.

**Абстрактный класс — это частично заполненный шаблон.**

Представьте процедуру обработки заказа на складе:

1. Проверить наличие товаров — одинаково для всех складов
2. Зарезервировать товар — одинаково
3. **Отправить** — зависит от склада (Москва → курьер, регион → почта)
4. Уведомить клиента — одинаково

Абстрактный класс задаёт общий алгоритм, но оставляет «дырки» для шагов, которые отличаются.

**Когда что использовать:**

- **Интерфейс** — когда нужен чистый контракт: «что ты умеешь делать?» Класс может реализовывать несколько интерфейсов.
- **Абстрактный класс** — когда есть общее состояние (поля) и общая логика, которую не хочется дублировать. Класс может наследовать только один абстрактный класс.

---

## 5.2 Hello World

### Интерфейс: платёжный шлюз

```java
package com.ecommerce.gateway;

/**
 * Контракт для платёжного шлюза.
 *
 * Любой провайдер, реализующий этот интерфейс,
 * может быть подключён к системе.
 * Интерфейс определяет ЧТО делать, но не КАК.
 */
public interface PaymentGateway {

    /**
     * Авторизует платёж — блокирует сумму на счёте покупателя.
     *
     * @param amountInCents сумма в минорных единицах (копейки/центы)
     * @param paymentToken  токен платёжного средства
     * @return ID транзакции для дальнейших операций
     */
    String authorize(long amountInCents, String paymentToken);

    /**
     * Подтверждает ранее авторизованный платёж. Деньги списываются.
     */
    void capture(String transactionId);

    /**
     * Возврат средств.
     */
    void refund(String transactionId, long amountInCents);

    /**
     * Default method — поведение по умолчанию.
     *
     * Реализации ДОЛЖНЫ переопределить для реального health check.
     * Default возвращает true только как заглушка для прототипирования —
     * в production без реальной проверки это опасно.
     */
    default boolean isAvailable() {
        return true;
    }
}
```

> **Почему `long amountInCents`, а не `BigDecimal`?** Многие платёжные API (Stripe, Тинькофф) принимают суммы в минорных единицах — центах, копейках. Это целое число, никаких проблем с округлением. `BigDecimal` нужен для пользовательского интерфейса и бизнес-логики (где оперируют рублями/долларами с копейками), а на уровне шлюза часто удобнее `long`. В учебном примере это ещё и упрощает код.

### Реализации

```java
package com.ecommerce.gateway;

import java.util.UUID;

/**
 * Реализация для Stripe.
 * В реальном коде здесь HTTP-клиент к api.stripe.com.
 */
public final class StripeGateway implements PaymentGateway {

    @Override
    public String authorize(long amountInCents, String paymentToken) {
        // В реальности: HTTP POST к api.stripe.com/v1/payment_intents
        System.out.println("[Stripe] Authorizing " + amountInCents + " cents");
        // Не логируем paymentToken — это секрет!
        return "stripe_txn_" + UUID.randomUUID();
    }

    @Override
    public void capture(String transactionId) {
        System.out.println("[Stripe] Capturing: " + transactionId);
    }

    @Override
    public void refund(String transactionId, long amountInCents) {
        System.out.println("[Stripe] Refunding " + amountInCents
            + " cents for: " + transactionId);
    }

    @Override
    public boolean isAvailable() {
        // Реальный health check: ping к Stripe API
        return true; // упрощённо
    }
}
```

```java
package com.ecommerce.gateway;

import java.util.UUID;

/**
 * Реализация для Тинькофф Эквайринг.
 */
public final class TinkoffGateway implements PaymentGateway {

    @Override
    public String authorize(long amountInCents, String paymentToken) {
        System.out.println("[Tinkoff] Authorizing " + amountInCents + " kopecks");
        return "tinkoff_" + UUID.randomUUID();
    }

    @Override
    public void capture(String transactionId) {
        System.out.println("[Tinkoff] Capturing: " + transactionId);
    }

    @Override
    public void refund(String transactionId, long amountInCents) {
        System.out.println("[Tinkoff] Refunding " + amountInCents
            + " kopecks for: " + transactionId);
    }
}
```

### Абстрактный класс: обработка заказа

```java
package com.ecommerce.processing;

/**
 * Абстрактный процессор заказов — паттерн Template Method.
 *
 * Определяет ОБЩИЙ алгоритм обработки.
 * Конкретный шаг, зависящий от склада (ship), — абстрактный.
 *
 * КОГДА использовать абстрактный класс:
 * 1. Есть общее состояние (поля), нужное подклассам
 * 2. Есть общая логика, которую не надо дублировать
 * 3. Есть шаблон алгоритма с «дыркой» для подклассов
 */
public abstract class AbstractOrderProcessor {

    private final String warehouseId;

    protected AbstractOrderProcessor(String warehouseId) {
        if (warehouseId == null || warehouseId.isBlank()) {
            throw new IllegalArgumentException("Warehouse ID required");
        }
        this.warehouseId = warehouseId;
    }

    /**
     * Template Method — определяет порядок шагов.
     * final — подклассы НЕ могут изменить порядок.
     */
    public final void processOrder(String orderId) {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID required");
        }

        System.out.println("Processing order " + orderId
            + " at warehouse " + warehouseId);

        validateOrder(orderId);
        reserveInventory(orderId);
        ship(orderId);            // ← АБСТРАКТНЫЙ: подклассы реализуют
        notifyCustomer(orderId);

        System.out.println("Order " + orderId + " processed ✅");
    }

    // Конкретные методы — общая логика
    private void validateOrder(String orderId) {
        System.out.println("  Validating order: " + orderId);
    }

    private void reserveInventory(String orderId) {
        System.out.println("  Reserving inventory for: " + orderId);
    }

    private void notifyCustomer(String orderId) {
        System.out.println("  Notifying customer about: " + orderId);
    }

    /**
     * Каждый склад отправляет по-своему.
     * Москва — курьером, регион — почтой.
     */
    protected abstract void ship(String orderId);

    protected String getWarehouseId() {
        return warehouseId;
    }
}
```

```java
package com.ecommerce.processing;

/**
 * Московский склад — отправка курьером.
 */
public final class MoscowWarehouseProcessor extends AbstractOrderProcessor {

    public MoscowWarehouseProcessor() {
        super("MSK-01");
    }

    @Override
    protected void ship(String orderId) {
        System.out.println("  📦 Shipping " + orderId + " via Moscow courier");
    }
}
```

```java
package com.ecommerce.processing;

/**
 * Региональный склад — отправка почтой.
 */
public final class RegionalWarehouseProcessor extends AbstractOrderProcessor {

    private final String region;

    public RegionalWarehouseProcessor(String warehouseId, String region) {
        super(warehouseId);
        if (region == null || region.isBlank()) {
            throw new IllegalArgumentException("Region required");
        }
        this.region = region;
    }

    @Override
    protected void ship(String orderId) {
        System.out.println("  📦 Shipping " + orderId
            + " via Russian Post from " + region);
    }
}
```

### Демонстрация

```java
package com.ecommerce;

import com.ecommerce.gateway.*;
import com.ecommerce.processing.*;

public class AbstractAndInterfaceDemo {

    public static void main(String[] args) {
        // === Интерфейс: подключаем любой шлюз ===
        PaymentGateway gateway = new StripeGateway();
        String txnId = gateway.authorize(9999, "tok_visa");
        gateway.capture(txnId);
        System.out.println();

        // Переключиться на Тинькофф — одна строка:
        gateway = new TinkoffGateway();
        txnId = gateway.authorize(9999, "tok_mir");
        gateway.capture(txnId);
        System.out.println();

        // === Абстрактный класс: разные склады ===
        AbstractOrderProcessor moscow = new MoscowWarehouseProcessor();
        moscow.processOrder("ORD-001");
        System.out.println();

        AbstractOrderProcessor kazan = new RegionalWarehouseProcessor("KZN-01", "Казань");
        kazan.processOrder("ORD-002");
    }
}
```

### Таблица: интерфейс vs абстрактный класс

|Критерий|Интерфейс|Абстрактный класс|
|---|---|---|
|Состояние (поля)|Только `static final` константы|Любые поля|
|Конструктор|Нет|Да|
|Множественная реализация|Да (`implements A, B, C`)|Нет (`extends` только один)|
|Default-методы|Да (Java 8+)|Конкретные методы|
|Когда использовать|Контракт: «что ты умеешь»|Шаблон: общая логика + состояние|
|Пример из JDK|`List`, `Map`, `Runnable`|`AbstractList`, `AbstractMap`|
|Пример из e-commerce|`PaymentGateway`|`AbstractOrderProcessor`|

---

## 5.3 Under the Hood

На уровне JVM интерфейсы и абстрактные классы обрабатываются по-разному, но после JIT-компиляции разница часто исчезает.

**Вызов через интерфейс** → инструкция байткода `invokeinterface`. JVM ищет реализацию метода через **itable** (interface method table). Класс может реализовывать много интерфейсов, поэтому поиск может быть чуть дороже.

**Вызов через абстрактный класс** → инструкция `invokevirtual`. JVM ищет через **vtable** (virtual method table), где индекс метода фиксирован. Поиск — O(1).

**На практике:** JIT-компилятор оптимизирует оба варианта через inline caches и де-виртуализацию. Если на конкретный вызов приходит один-два типа объектов (а это обычная ситуация), JIT превращает виртуальный вызов в прямой или вообще встраивает код метода. Разница между `invokeinterface` и `invokevirtual` становится неизмеримой.

> **Вывод:** Не выбирайте между интерфейсом и абстрактным классом ради «производительности». Выбирайте по смыслу дизайна.

### Diamond Problem с default-методами

Если класс реализует два интерфейса с одинаковым default-методом, компилятор **заставит** явно разрешить конфликт:

```java
package com.ecommerce.edgecases;

public class DiamondProblemDemo {

    interface Auditable {
        default String auditInfo() {
            return "Auditable: " + getClass().getSimpleName();
        }
    }

    interface Loggable {
        default String auditInfo() {
            return "Loggable: " + getClass().getSimpleName();
        }
    }

    // Реализует ОБА интерфейса с одинаковым default-методом.
    // Без @Override — ошибка компиляции:
    //   "inherits unrelated defaults for auditInfo()"
    static class AuditableOrder implements Auditable, Loggable {

        @Override
        public String auditInfo() {
            // Можно вызвать default конкретного интерфейса:
            return Auditable.super.auditInfo()
                + " | " + Loggable.super.auditInfo();
        }
    }

    public static void main(String[] args) {
        AuditableOrder order = new AuditableOrder();
        System.out.println(order.auditInfo());
        // Auditable: AuditableOrder | Loggable: AuditableOrder
    }
}
```

---

## 5.4 Production Grade

### Sealed-интерфейс для статусов заказа (Java 17+)

Обычный `enum` подходит, когда все варианты одинаковы по структуре: `PENDING`, `CONFIRMED`, `SHIPPED`. Но что если каждый статус несёт **свои данные**? У «Отправлен» есть трек-номер, у «Отменён» — причина, у «Доставлен» — подпись получателя.

`sealed` + `record` решает эту задачу:

```java
package com.ecommerce.status;

import java.time.Instant;

/**
 * Sealed interface: компилятор знает ВСЕ реализации.
 * Это позволяет делать exhaustive switch (Java 21).
 *
 * Отличие от enum:
 * - enum: все константы одинаковы по структуре (PENDING, SHIPPED)
 * - sealed + record: каждый вариант имеет свои поля
 *
 * Компромисс: enum — это singleton-константы (дешёвые),
 * а record — новые объекты при каждом создании (аллокации).
 * Для статусов заказа это обычно не проблема (один статус на заказ),
 * но для горячего кода стоит задуматься.
 *
 * Важный нюанс: record генерирует equals/hashCode по ВСЕМ полям,
 * включая timestamp. Два статуса Pending, созданных в разное время,
 * НЕ будут равны. Если нужно сравнивать «по категории» —
 * используйте enum или переопределите equals().
 */
public sealed interface OrderEvent
    permits OrderEvent.Created,
            OrderEvent.Confirmed,
            OrderEvent.Shipped,
            OrderEvent.Delivered,
            OrderEvent.Cancelled {

    Instant timestamp();

    record Created(Instant timestamp) implements OrderEvent {}
    record Confirmed(Instant timestamp, String paymentId) implements OrderEvent {}
    record Shipped(Instant timestamp, String trackingNumber) implements OrderEvent {}
    record Delivered(Instant timestamp, String signedBy) implements OrderEvent {}
    record Cancelled(Instant timestamp, String reason) implements OrderEvent {}
}
```

```java
package com.ecommerce.status;

import java.time.Instant;

public class OrderEventHandler {

    /**
     * Exhaustive switch (Java 21):
     * компилятор гарантирует, что все варианты обработаны.
     * Добавишь новый record в sealed interface → ошибка компиляции здесь.
     */
    public String describe(OrderEvent event) {
        return switch (event) {
            case OrderEvent.Created c ->
                "Заказ создан: " + c.timestamp();
            case OrderEvent.Confirmed c ->
                "Подтверждён, оплата: " + c.paymentId();
            case OrderEvent.Shipped s ->
                "Отправлен, трек: " + s.trackingNumber();
            case OrderEvent.Delivered d ->
                "Доставлен, подпись: " + d.signedBy();
            case OrderEvent.Cancelled x ->
                "Отменён: " + x.reason();
        };
    }

    public static void main(String[] args) {
        OrderEvent event = new OrderEvent.Shipped(
            Instant.now(), "TRACK-RU-123456"
        );

        OrderEventHandler handler = new OrderEventHandler();
        System.out.println(handler.describe(event));
        // Отправлен, трек: TRACK-RU-123456
    }
}
```

> **Версии Java:** `sealed` — Java 17 (final). Pattern matching в `switch` — Java 21 (final). Если ваш проект на более ранней версии, используйте `if-else` с `instanceof` или обычный `enum`.

### Тестирование: ручной мок vs Mockito

Интерфейсы легко тестировать — можно создать заглушку прямо в тесте:

```java
package com.ecommerce.gateway;

import org.junit.jupiter.api.Test;
import static org.junit.jupiter.api.Assertions.*;

class PaymentGatewayTest {

    /**
     * Ручной мок — никаких библиотек, чистая Java.
     * Это наглядно показывает силу интерфейсов:
     * мы создаём «фейковый» шлюз, который ведёт себя предсказуемо.
     */
    static class FakeGateway implements PaymentGateway {
        boolean authorizeCalled = false;
        boolean captureCalled = false;
        String lastTxnId = null;

        @Override
        public String authorize(long amountInCents, String paymentToken) {
            authorizeCalled = true;
            lastTxnId = "fake_txn_001";
            return lastTxnId;
        }

        @Override
        public void capture(String transactionId) {
            captureCalled = true;
        }

        @Override
        public void refund(String transactionId, long amountInCents) {
            // не нужен в этом тесте
        }
    }

    @Test
    void authorizeAndCapture() {
        FakeGateway gateway = new FakeGateway();

        String txnId = gateway.authorize(9999, "tok_test");
        gateway.capture(txnId);

        assertTrue(gateway.authorizeCalled);
        assertTrue(gateway.captureCalled);
        assertEquals("fake_txn_001", txnId);
    }

    /**
     * Тестирование абстрактного класса — через минимальную реализацию.
     * Мы проверяем, что template method вызывает ship().
     */
    @Test
    void abstractProcessorCallsShip() {
        // Анонимный подкласс прямо в тесте
        var processor = new com.ecommerce.processing.AbstractOrderProcessor("TEST") {
            boolean shipCalled = false;

            @Override
            protected void ship(String orderId) {
                shipCalled = true;
            }
        };

        processor.processOrder("ORD-TEST");
        assertTrue(processor.shipCalled);
    }
}
```

> **Mockito** — популярная библиотека, которая генерирует такие заглушки автоматически (`mock(PaymentGateway.class)`). Это удобнее для больших проектов, но ручной мок нагляднее показывает, **зачем** нужны интерфейсы: любой класс, реализующий контракт, может быть подставлен вместо настоящего.

---

## 5.5 Edge Cases

### Нужен ли интерфейс, если реализация одна?

Этот вопрос разделяет команды.

**Аргументы «за» интерфейс:**

- Тестируемость: можно подставить заглушку (как `FakeGateway` выше)
- Расширяемость: завтра может появиться вторая реализация
- Чистота зависимостей: код зависит от контракта, не от реализации

**Аргументы «против»:**

- YAGNI (You Ain't Gonna Need It): интерфейс ради интерфейса — бойлерплейт
- Навигация в IDE: Ctrl+Click ведёт к интерфейсу, а не к реализации
- `IOrderService` → `OrderServiceImpl` — это не дизайн, это ритуал

**Рекомендация:** интерфейс оправдан, когда есть реальная вариативность (сейчас или в ближайшем будущем), когда это SPI для внешних модулей, или когда без него невозможно тестировать. Если единственная причина — «так принято», интерфейс, скорее всего, не нужен.

---

# 6. Композиция против наследования

---

## 6.1 Концепт

**Наследование:** отношение «является» (is-a).  
`EmailNotification` **является** `Notification` — логично.

**Композиция:** отношение «содержит / использует» (has-a).  
`Order` **содержит** `PaymentMethod` — заказ не является способом оплаты.

Аналогия:

- **Наследование** = вырезать процессор из старого компьютера и впаять в новый. Сломалось? Удачи с отладкой.
- **Композиция** = собрать компьютер из компонентов: процессор, память, диск. Сломался диск — заменил. Остальное работает.

Новички иногда пишут:

```java
class OrderService extends JdbcTemplate { ... }
```

Чтобы «иметь доступ к методам JdbcTemplate». Но OrderService **не является** шаблоном JDBC-запросов. Он **использует** его. Это композиция, не наследование.

---

## 6.2 Проблема: Fragile Base Class

Классический пример из книги Effective Java (Item 18), адаптированный для e-commerce.

**Задача:** подсчитать, сколько раз добавлялись заказы в коллекцию.

**Попытка через наследование:**

```java
package com.ecommerce.fragile;

import java.util.ArrayList;
import java.util.Collection;

/**
 * ПЛОХО: наследуем ArrayList, чтобы считать добавления.
 *
 * Проблема: мы зависим от ВНУТРЕННЕЙ РЕАЛИЗАЦИИ ArrayList.
 * Если она изменится — наш код сломается непредсказуемо.
 */
public class InstrumentedOrderList<E> extends ArrayList<E> {

    private int addCount = 0;

    @Override
    public boolean add(E element) {
        addCount++;
        return super.add(element);
    }

    @Override
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return super.addAll(c);
    }

    public int getAddCount() {
        return addCount;
    }
}
```

Кажется просто: `add` считает +1, `addAll` считает +N. Но вот подвох:

```java
package com.ecommerce.fragile;

import java.util.List;

public class FragileBaseClassDemo {

    public static void main(String[] args) {
        InstrumentedOrderList<String> list = new InstrumentedOrderList<>();

        list.addAll(List.of("ORD-001", "ORD-002", "ORD-003"));

        System.out.println("Expected: 3");
        System.out.println("Actual:   " + list.getAddCount());
    }
}
```

Результат **зависит от реализации ArrayList в вашей JDK**.

В оригинальном примере из Effective Java использовался `HashSet`, где `addAll()` внутри вызывает `this.add()` для каждого элемента. Тогда счётчик удваивается: `addAll` добавляет N, а потом каждый внутренний `add` — ещё по одному.

С `ArrayList` в OpenJDK `addAll()` обычно использует `System.arraycopy` и **не вызывает** `this.add()`. Поэтому счётчик может показать 3.

**Но в этом и суть проблемы:** вы не знаете, как базовый класс реализован внутри. Сегодня `arraycopy`, завтра — цикл с `add()`. Или другая JDK. Или другая версия. Ваш код зависит от **деталей реализации, которые не являются контрактом**.

Это называется **Fragile Base Class Problem**: изменение в базовом классе ломает подкласс, хотя публичный контракт не изменился.

---

## 6.3 Решение: композиция + делегирование

```java
package com.ecommerce.fragile;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

/**
 * ХОРОШО: содержим список как private поле.
 * Делегируем нужные методы, добавляя свою логику.
 * НЕ зависим от внутренней реализации ArrayList.
 */
public class InstrumentedCollection<E> implements Iterable<E> {

    // Делегат скрыт за private.
    // Внешний код не знает, что внутри ArrayList.
    private final List<E> delegate = new ArrayList<>();

    private int addCount = 0;

    public boolean add(E element) {
        addCount++;
        return delegate.add(element);
    }

    /**
     * Ключевое отличие: мы вызываем delegate.addAll(),
     * не this.add() в цикле. Даже если ArrayList внутри
     * вызовет свой add(), это add() на delegate (обычном ArrayList),
     * а не на нашем объекте. Наш addCount не дёрнется лишний раз.
     */
    public boolean addAll(Collection<? extends E> c) {
        addCount += c.size();
        return delegate.addAll(c);
    }

    public int getAddCount() { return addCount; }
    public int size() { return delegate.size(); }
    public E get(int index) { return delegate.get(index); }

    @Override
    public Iterator<E> iterator() { return delegate.iterator(); }
}
```

```java
package com.ecommerce.fragile;

import java.util.List;

public class CompositionFixDemo {

    public static void main(String[] args) {
        InstrumentedCollection<String> collection = new InstrumentedCollection<>();

        collection.addAll(List.of("ORD-001", "ORD-002", "ORD-003"));

        System.out.println("Expected: 3");
        System.out.println("Actual:   " + collection.getAddCount());
        // Actual: 3 ✅ — всегда правильно, независимо от реализации ArrayList

        collection.add("ORD-004");
        System.out.println("After add: " + collection.getAddCount());
        // After add: 4 ✅
    }
}
```

> **Компромисс:** `InstrumentedCollection` — это **не** `List`. Код, ожидающий `List`, не примет его. Если нужна полная совместимость с `List`, придётся реализовать все методы интерфейса `List` через делегирование (или использовать `ForwardingList` из Guava). Композиция требует чуть больше кода, но даёт предсказуемость.

---

## 6.4 Когда наследование оправдано

Наследование — не зло. Это инструмент. Оправдано, когда:

1. **Вы контролируете и базовый, и дочерний класс.** Они в одном модуле, под одной командой.
    
2. **Skeletal implementation** — класс спроектирован для наследования и это задокументировано. Как `AbstractList` в JDK: в Javadoc чётко сказано, какие методы нужно переопределить.
    
3. **Sealed hierarchies** — все подтипы известны, в одном пакете:
    
    Java
    
    ```java
    sealed class Shape permits Circle, Rectangle, Triangle
    ```
    
4. **Template Method** — осознанно и документировано (как `AbstractOrderProcessor` выше).
    

**Правило Effective Java:** «Design and document for inheritance, or else prohibit it.» Если класс не предназначен для наследования — сделайте его `final`.

---

## 6.5 Композиция в действии: CheckoutService

Типичный сервис в реальном приложении **не наследует** свои зависимости. Он **содержит** их:

```java
package com.ecommerce.service;

import com.ecommerce.gateway.PaymentGateway;

/**
 * Сервис оформления заказа.
 *
 * НЕ наследует PaymentGateway или NotificationSender.
 * СОДЕРЖИТ их как зависимости, переданные через конструктор.
 *
 * Результат:
 * - Можно подменить любую зависимость (тест/другая реализация)
 * - Каждый компонент тестируется отдельно
 * - Добавить новый шлюз = создать класс + передать в конструктор
 */
public class CheckoutService {

    private final PaymentGateway paymentGateway;
    private final NotificationSender notificationSender;

    /**
     * Зависимости передаются через конструктор.
     *
     * В Spring это называется Constructor Injection —
     * Spring сам создаёт объекты и передаёт их сюда.
     * Но можно использовать и без Spring:
     *   new CheckoutService(new StripeGateway(), new EmailSender())
     */
    public CheckoutService(PaymentGateway paymentGateway,
                           NotificationSender notificationSender) {
        if (paymentGateway == null) {
            throw new IllegalArgumentException("Payment gateway required");
        }
        if (notificationSender == null) {
            throw new IllegalArgumentException("Notification sender required");
        }
        this.paymentGateway = paymentGateway;
        this.notificationSender = notificationSender;
    }

    /**
     * Оформление заказа. Композиция в действии:
     * сервис оркестрирует компоненты, не зная их внутренней логики.
     */
    public String checkout(String orderId, long amountInCents,
                           String paymentToken) {
        System.out.println("Checkout: order " + orderId);

        // 1. Оплата (Stripe? Tinkoff? — зависит от того, что передали)
        String txnId = paymentGateway.authorize(amountInCents, paymentToken);
        paymentGateway.capture(txnId);

        // 2. Уведомление (Email? SMS? — зависит от реализации)
        notificationSender.sendConfirmation(orderId);

        System.out.println("Checkout complete: " + txnId);
        return txnId;
    }
}
```

```java
package com.ecommerce.service;

/**
 * Контракт для отправки уведомлений.
 */
public interface NotificationSender {
    void sendConfirmation(String orderId);
}
```

```java
package com.ecommerce.service;

public class EmailNotificationSender implements NotificationSender {
    @Override
    public void sendConfirmation(String orderId) {
        System.out.println("📧 Email sent for order " + orderId);
    }
}
```

Использование:

```java
package com.ecommerce.service;

import com.ecommerce.gateway.StripeGateway;

public class CheckoutDemo {

    public static void main(String[] args) {
        // Собираем сервис из компонентов — как компьютер из деталей
        CheckoutService service = new CheckoutService(
            new StripeGateway(),
            new EmailNotificationSender()
        );

        service.checkout("ORD-001", 9999, "tok_visa");

        // Хотим SMS вместо email? Меняем одну деталь:
        CheckoutService smsService = new CheckoutService(
            new StripeGateway(),
            orderId -> System.out.println("📱 SMS sent for " + orderId)
        );

        smsService.checkout("ORD-002", 4999, "tok_mir");
    }
}
```

---

## 6.6 Шпаргалка: наследование vs композиция

| Критерий            | Наследование                  | Композиция                             |
| ------------------- | ----------------------------- | -------------------------------------- |
| Связь               | Тесная (tight coupling)       | Слабая (loose coupling)                |
| Гибкость            | Зафиксирована при компиляции  | Можно менять в runtime                 |
| Тестируемость       | Сложнее (тянет базовый класс) | Проще (подставляем заглушки)           |
| Инкапсуляция        | `protected` — дыра            | Чёткий API через интерфейсы            |
| Количество кода     | Меньше (extends!)             | Чуть больше (делегирование)            |
| Хрупкость           | Fragile Base Class Problem    | Изоляция от чужих изменений            |
| Стоимость поддержки | Растёт с глубиной иерархии    | Пропорциональна количеству компонентов |

> **Правило на каждый день:** Начинайте с композиции. Переходите к наследованию только когда чётко видите отношение «является» (is-a), контролируете всю иерархию и готовы её документировать

# 7. Records, Sealed Classes и современный ООП (Java 17–21)

---

## 7.1 Records — классы для данных

### Проблема

Сколько раз вы писали класс, который просто хранит данные? Поля, конструктор, геттеры, `equals()`, `hashCode()`, `toString()` — для пяти полей это легко 70–80 строк кода, где каждая строка очевидна и скучна.

`record` решает эту проблему. Это специальный вид класса, введённый в Java 16, чья единственная задача — быть **прозрачным носителем неизменяемых данных**. Как бейджик или паспорт: он просто показывает информацию, и исправить его ручкой нельзя.

### Простейший record

```java
package com.ecommerce.dto;

import java.math.BigDecimal;

/**
 * Одна строка — вместо 80 строк бойлерплейта.
 *
 * Java автоматически генерирует:
 * - private final поля: orderId, total, status
 * - accessor-методы: orderId(), total(), status() (НЕ getOrderId()!)
 * - конструктор со всеми параметрами
 * - equals() — сравнивает все компоненты
 * - hashCode() — по всем компонентам
 * - toString() — включает имя и все компоненты
 *
 * Record — final. Наследоваться от него нельзя.
 * Но реализовывать интерфейсы — можно.
 */
public record OrderSummary(
        String orderId,
        BigDecimal total,
        String status
) {}
```

Это **весь класс**. Ни строки лишнего кода. Давайте посмотрим, как он работает:

```java
package com.ecommerce.dto;

import java.math.BigDecimal;

public class RecordBasicsDemo {

    public static void main(String[] args) {
        // Создание — обычный конструктор
        OrderSummary order = new OrderSummary(
            "ORD-42", new BigDecimal("299.99"), "CONFIRMED"
        );

        // Accessor-методы: orderId(), НЕ getOrderId()
        System.out.println("ID: " + order.orderId());
        System.out.println("Total: " + order.total());
        System.out.println("Status: " + order.status());

        // toString() сгенерирован автоматически
        System.out.println(order);
        // OrderSummary[orderId=ORD-42, total=299.99, status=CONFIRMED]

        // equals() сравнивает все компоненты
        OrderSummary same = new OrderSummary(
            "ORD-42", new BigDecimal("299.99"), "CONFIRMED"
        );
        System.out.println("equals: " + order.equals(same)); // true
    }
}
```

### Compact-конструктор и валидация

Record может содержать тело: валидацию, дополнительные методы, статические фабрики. Валидация пишется в **compact-конструкторе** — специальном синтаксисе без списка параметров:

```java
package com.ecommerce.dto;

import java.math.BigDecimal;
import java.util.List;
import java.util.Objects;

/**
 * Позиция заказа — маленький value object, идеальный для record.
 */
public record LineItem(
        String productId,
        String productName,
        int quantity,
        BigDecimal unitPrice
) {
    // Compact-конструктор: параметры уже доступны по имени.
    // Присваивание (this.productId = productId) произойдёт АВТОМАТИЧЕСКИ
    // в конце блока — писать его не нужно и нельзя.
    public LineItem {
        if (productId == null || productId.isBlank()) {
            throw new IllegalArgumentException("Product ID required");
        }
        if (productName == null || productName.isBlank()) {
            throw new IllegalArgumentException("Product name required");
        }
        Objects.requireNonNull(unitPrice, "Unit price required");
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
        if (unitPrice.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Price must be non-negative");
        }
    }

    /** Стоимость позиции = цена × количество */
    public BigDecimal lineTotal() {
        return unitPrice.multiply(BigDecimal.valueOf(quantity));
    }
}
```

### Defensive copy — защита от мутации

Record гарантирует, что **ссылки** на поля неизменяемы (`final`). Но если поле — `List` — его **содержимое** можно изменить снаружи. Это называется **shallow immutability**.

```java
package com.ecommerce.dto;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

/**
 * Record С defensive copy — безопасный.
 */
public record OrderDetails(
        String orderId,
        List<LineItem> items,
        BigDecimal total,
        Instant createdAt
) {
    public OrderDetails {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID required");
        }
        Objects.requireNonNull(items, "Items required");
        Objects.requireNonNull(total, "Total required");
        Objects.requireNonNull(createdAt, "Created at required");

        // DEFENSIVE COPY: создаём неизменяемую копию списка.
        // Без этого вызывающий код мог бы изменить содержимое через
        // свою ссылку на оригинальный список.
        items = List.copyOf(items);
    }

    public static OrderDetails createNow(
            String orderId, List<LineItem> items, BigDecimal total) {
        return new OrderDetails(orderId, items, total, Instant.now());
    }
}
```

Демонстрация проблемы **без** defensive copy:

```java
package com.ecommerce.dto;

import java.util.ArrayList;
import java.util.List;

public class ShallowImmutabilityDemo {

    // Record БЕЗ defensive copy
    record UnsafeOrder(String id, List<String> tags) {}

    public static void main(String[] args) {
        ArrayList<String> tags = new ArrayList<>(List.of("electronics", "sale"));
        UnsafeOrder order = new UnsafeOrder("ORD-1", tags);

        System.out.println("Before: " + order.tags()); // [electronics, sale]

        // Вызывающий код мутирует оригинальный список —
        // и record «ломается»
        tags.add("INJECTED");
        System.out.println("After:  " + order.tags()); // [electronics, sale, INJECTED]
        // Record якобы неизменяемый, но данные изменились!

        // С OrderDetails это невозможно:
        // compact-конструктор делает List.copyOf(items)
    }
}
```

> **Правило:** Если record содержит `List`, `Map`, `Set` или другой мутабельный тип — **всегда** делайте `List.copyOf()` / `Map.copyOf()` / `Set.copyOf()` в compact-конструкторе.

### Record и интерфейсы

Record может реализовывать интерфейсы — полиморфизм работает как обычно:

```java
package com.ecommerce.dto;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;

public interface Summarizable {
    String summary();
}

public record PaymentReceipt(
        String paymentId,
        BigDecimal amount,
        String method,
        Instant timestamp
) implements Summarizable {

    public PaymentReceipt {
        Objects.requireNonNull(paymentId, "Payment ID required");
        Objects.requireNonNull(amount, "Amount required");
        Objects.requireNonNull(method, "Method required");
        Objects.requireNonNull(timestamp, "Timestamp required");
    }

    @Override
    public String summary() {
        return "Payment " + paymentId + ": " + amount + " via " + method;
    }
}
```

### Что нужно знать о record

|Свойство|Record|Обычный класс|
|---|---|---|
|Поля|Только `final`, объявлены в заголовке|Любые|
|Дополнительные instance-поля|Нельзя|Можно|
|Наследование|`final`, нельзя `extends`|Любой суперкласс|
|Интерфейсы|Можно `implements`|Можно `implements`|
|`equals`/`hashCode`/`toString`|Генерируются|Нужно писать|
|Accessor-методы|`name()`, не `getName()`|Нужно писать|

---

## 7.2 Sealed Classes — ограниченные иерархии

### Идея

Представьте светофор. У него может быть **только** три цвета: красный, жёлтый, зелёный. Четвёртого не дано.

`sealed` делает то же самое с классами: ограничивает набор допустимых наследников. Компилятор **знает все возможные подтипы** и может проверить, что вы не забыли обработать ни один.

### Sealed + Record = события заказа

Обычный `enum` подходит, когда все варианты одинаковы по структуре: `PENDING`, `SHIPPED`. Но что если каждый вариант несёт **свои данные**? У «Отправлен» есть трек-номер, у «Отменён» — причина.

```java
package com.ecommerce.events;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;

/**
 * Sealed interface: ТОЛЬКО перечисленные после "permits"
 * классы могут его реализовывать. Никто больше.
 *
 * Все permitted-типы должны быть в том же пакете.
 * Каждый обязан быть final, sealed или non-sealed.
 * Record автоматически final — идеальный кандидат.
 */
public sealed interface OrderEvent permits
        OrderEvent.Created,
        OrderEvent.Paid,
        OrderEvent.Shipped,
        OrderEvent.Delivered,
        OrderEvent.Cancelled {

    String orderId();
    Instant timestamp();

    record Created(
            String orderId,
            Instant timestamp,
            String customerId,
            BigDecimal initialTotal
    ) implements OrderEvent {
        public Created {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(customerId);
            Objects.requireNonNull(initialTotal);
        }
    }

    record Paid(
            String orderId,
            Instant timestamp,
            String paymentId,
            BigDecimal paidAmount,
            String paymentMethod
    ) implements OrderEvent {
        public Paid {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(paymentId);
            Objects.requireNonNull(paidAmount);
            Objects.requireNonNull(paymentMethod);
        }
    }

    record Shipped(
            String orderId,
            Instant timestamp,
            String trackingNumber,
            String carrier
    ) implements OrderEvent {
        public Shipped {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(trackingNumber);
            Objects.requireNonNull(carrier);
        }
    }

    record Delivered(
            String orderId,
            Instant timestamp,
            String signedBy // может быть null (оставили у двери)
    ) implements OrderEvent {
        public Delivered {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
        }
    }

    record Cancelled(
            String orderId,
            Instant timestamp,
            String reason,
            boolean refundIssued
    ) implements OrderEvent {
        public Cancelled {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(reason);
        }
    }
}
```

### Pattern Matching for Switch (Java 21)

Теперь — обработка событий. Компилятор **требует** обработать все варианты sealed-интерфейса. Если добавите новый record и забудете ветку — код не скомпилируется.

```java
package com.ecommerce.events;

import java.math.BigDecimal;
import java.time.Instant;

public class OrderEventProcessor {

    /**
     * switch expression с pattern matching.
     *
     * Каждый case «деструктурирует» record:
     * мы получаем переменную нужного типа с доступом к полям.
     *
     * НЕТ default! Компилятор знает все варианты sealed-интерфейса.
     * Добавите новый record → ошибка компиляции здесь.
     */
    public String processEvent(OrderEvent event) {
        // Защита от null: sealed гарантирует подтипы,
        // но null — не подтип, его нужно проверять отдельно
        if (event == null) {
            throw new IllegalArgumentException("Event must not be null");
        }

        return switch (event) {
            case OrderEvent.Created created -> {
                System.out.printf("📦 New order %s from %s, total: %s%n",
                    created.orderId(), created.customerId(), created.initialTotal());
                yield "Order " + created.orderId() + " created";
            }

            case OrderEvent.Paid paid -> {
                System.out.printf("💳 Order %s paid: %s via %s%n",
                    paid.orderId(), paid.paidAmount(), paid.paymentMethod());
                yield "Payment " + paid.paymentId() + " processed";
            }

            case OrderEvent.Shipped shipped -> {
                System.out.printf("🚚 Order %s shipped via %s, tracking: %s%n",
                    shipped.orderId(), shipped.carrier(), shipped.trackingNumber());
                yield "Tracking: " + shipped.trackingNumber();
            }

            case OrderEvent.Delivered delivered -> {
                String signee = delivered.signedBy() != null
                    ? delivered.signedBy()
                    : "left at door";
                System.out.printf("✅ Order %s delivered, signed by: %s%n",
                    delivered.orderId(), signee);
                yield "Order " + delivered.orderId() + " delivered";
            }

            case OrderEvent.Cancelled cancelled -> {
                System.out.printf("❌ Order %s cancelled: %s (refund: %s)%n",
                    cancelled.orderId(), cancelled.reason(),
                    cancelled.refundIssued() ? "yes" : "no");
                yield "Order " + cancelled.orderId() + " cancelled";
            }
        };
    }

    public static void main(String[] args) {
        OrderEventProcessor processor = new OrderEventProcessor();

        OrderEvent[] events = {
            new OrderEvent.Created("ORD-100", Instant.now(),
                "CUST-42", new BigDecimal("299.99")),
            new OrderEvent.Paid("ORD-100", Instant.now(),
                "PAY-555", new BigDecimal("299.99"), "CARD"),
            new OrderEvent.Shipped("ORD-100", Instant.now(),
                "TRK-789", "DHL"),
            new OrderEvent.Delivered("ORD-100", Instant.now(),
                "John Doe"),
            new OrderEvent.Cancelled("ORD-200", Instant.now(),
                "Customer changed mind", true),
        };

        for (OrderEvent event : events) {
            String result = processor.processEvent(event);
            System.out.println("→ " + result);
            System.out.println();
        }
    }
}
```

> **Версии Java.** `sealed` — Java 17 (stable). Pattern matching в `switch` — Java 21 (stable). На более ранних версиях используйте `if-else` с `instanceof`.

### Сравнение: до и после

**До Java 17** — instanceof каскад. Компилятор **не** проверяет полноту. Забыли ветку — тихий баг в runtime:

```java
// ❌ Компилятор НЕ предупредит о пропущенном варианте
if (event instanceof OrderEvent.Created created) {
    return "Created: " + created.orderId();
} else if (event instanceof OrderEvent.Paid paid) {
    return "Paid: " + paid.paymentId();
} else {
    // Забыли Shipped, Delivered, Cancelled...
    throw new IllegalStateException("Unknown event");
}
```

**С Java 21** — exhaustive switch. Добавили новый record → **ошибка компиляции** во всех switch'ах, пока не обработаете его. Целая категория багов устранена.

> **Честный trade-off:** Exhaustiveness — это палка о двух концах. Добавление нового варианта в sealed-интерфейс ломает **все** switch'и в кодовой базе. В маленьком проекте — спасение. В большом монолите с 50 switch'ами — массовый рефакторинг. Sealed лучше всего работает, когда набор вариантов меняется редко.

---

## 7.3 Under the Hood

На уровне JVM record — это **обычный `final` класс**, наследующий `java.lang.Record`. В памяти record-объект занимает столько же места, сколько эквивалентный обычный класс с теми же `final`-полями. Никакой магии, никакой специальной области кучи.

Интересная деталь: `equals()`, `hashCode()` и `toString()` генерируются через инструкцию `invokedynamic`. При первом вызове JVM создаёт оптимизированную реализацию для конкретного набора полей и кэширует её. После JIT-прогрева производительность сравнима с ручной реализацией.

Для sealed-интерфейсов компилятор добавляет атрибут `PermittedSubclasses` в class-файл. При загрузке класса JVM проверяет, что каждый наследник есть в этом списке. Попытка создать «нелегального» наследника через манипуляцию байткодом приведёт к ошибке загрузки.

JIT-компилятор может использовать информацию о sealed для де-виртуализации (знает все возможные подтипы), но это не гарантия — зависит от профиля выполнения, размера методов и многих других факторов.

> **Проверить layout в памяти** можно через JOL: `ClassLayout.parseClass(OrderSummary.class).toPrintable()`. Результат зависит от JVM, платформы и флагов — не принимайте конкретные цифры из статей за истину.

---

## 7.4 Edge Cases

### `equals()` и `BigDecimal`

Record-овский `equals()` сравнивает **все** компоненты. Для `BigDecimal` это означает, что учитывается **scale** (количество знаков после запятой):

```java
package com.ecommerce.edgecases;

import java.math.BigDecimal;

public class RecordEqualsPitfall {

    record Price(String currency, BigDecimal amount) {}

    public static void main(String[] args) {
        Price p1 = new Price("USD", new BigDecimal("100.0"));
        Price p2 = new Price("USD", new BigDecimal("100.00"));

        // BigDecimal.equals() учитывает scale:
        // "100.0" и "100.00" — НЕ равны!
        System.out.println("equals: " + p1.equals(p2));    // false!
        System.out.println("compareTo: " +
            (p1.amount().compareTo(p2.amount()) == 0));     // true

        // Это может сломать HashMap/HashSet: вставили с одним scale,
        // ищем с другим — не находим.

        // Если нужно сравнение по ЗНАЧЕНИЮ (без учёта scale),
        // record не подойдёт «из коробки». Варианты:
        // 1. Нормализовать scale при создании (в compact-конструкторе)
        // 2. Использовать обычный класс с кастомным equals()
    }
}
```

### `equals()` и `Instant`

Если record содержит timestamp, два одинаковых по смыслу объекта, созданных в разное время, **не будут равны**:

```java
record AuditEntry(String action, String userId, Instant timestamp) {}

AuditEntry e1 = new AuditEntry("LOGIN", "user-1", Instant.now());
// ... через секунду ...
AuditEntry e2 = new AuditEntry("LOGIN", "user-1", Instant.now());

System.out.println(e1.equals(e2)); // false — разные timestamp!
```

Если нужно сравнение «по бизнес-ключу» (без timestamp) — record в стандартном виде не подойдёт. Можно переопределить `equals()`/`hashCode()` вручную, но тогда теряется часть преимуществ record.

### `toString()` и чувствительные данные

Record генерирует `toString()` со **всеми** компонентами. Это удобно для отладки, но опасно в production: если record содержит email, номер телефона, токен — они попадут в логи.

```java
// toString() выведет ВСЁ, включая email
record UserProfile(String userId, String name, String email) {}
// UserProfile[userId=U-123, name=Alice, email=alice@secret.com]
```

Решение: переопределить `toString()` вручную, убрав чувствительные поля.

### Record не подходит как JPA Entity

JPA (Hibernate) требует:

- Конструктор без аргументов (у record его нет)
- Возможность менять поля (у record все `final`)
- Возможность создавать proxy-подклассы (record — `final`)

Record **отлично** подходит для DTO, projection, параметров запросов и ответов API. Но не для JPA Entity.

### Record и наследование

Record нельзя наследовать. Если нужны варианты — используйте sealed interface:

```java
sealed interface OrderSummary permits StandardOrder, VipOrder {
    String orderId();
    BigDecimal total();
}

record StandardOrder(String orderId, BigDecimal total, int itemCount)
    implements OrderSummary {}

record VipOrder(String orderId, BigDecimal total, int itemCount,
                BigDecimal loyaltyPoints, String tier)
    implements OrderSummary {}
```

# 8. Real World: хорошие и плохие иерархии

Теория — это фундамент. Но настоящее понимание ООП приходит, когда вы видите, как принципы работают (и нарушаются) в коде, которым пользуются миллионы разработчиков.

---

## 8.1 JDK — удачный дизайн: Collections Framework

Самый частый совет в Java: **«программируй на интерфейсе, а не на реализации»**. Collections Framework — хороший пример этого принципа.

```java
package com.ecommerce.realworld;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

public class CollectionsDesignDemo {

    public static void main(String[] args) {
        // Тип переменной — List (интерфейс), не ArrayList (реализация)
        List<String> orderIds = new ArrayList<>();
        orderIds.add("ORD-001");
        orderIds.add("ORD-002");

        // Метод принимает List — ему всё равно, что внутри
        printOrders(orderIds);

        // Можно передать LinkedList — метод не изменится
        List<String> otherIds = new LinkedList<>();
        otherIds.add("ORD-003");
        printOrders(otherIds);
    }

    // Принимает интерфейс — работает с любой реализацией
    static void printOrders(List<String> orderIds) {
        for (String id : orderIds) {
            System.out.println("Processing: " + id);
        }
    }
}
```

**Что здесь хорошего:**

- API (`List`) отделён от реализации (`ArrayList`, `LinkedList`)
- Код `printOrders` не привязан к конкретному типу списка
- Новую реализацию `List` можно создать, не трогая существующий код

**Честное предупреждение:** «можно подменить реализацию» не означает «можно подменить бездумно». У `ArrayList` и `LinkedList` разная производительность: `ArrayList` быстрее для доступа по индексу, `LinkedList` — для вставки в середину. Замена одного на другое может незаметно ухудшить производительность. Интерфейс гарантирует одинаковый **контракт** (какие методы есть), но не одинаковое **поведение** (насколько быстро они работают).

---

## 8.2 JDK — неудачный дизайн: Stack и Properties

В JDK есть примеры, где наследование использовано неправильно. Эти ошибки из 1990-х живут до сих пор — исправить их нельзя, потому что миллионы программ зависят от текущего поведения.

### Stack extends Vector

Представьте стопку тарелок в столовой. Вы можете положить тарелку сверху (`push`) или снять верхнюю (`pop`). Выдёргивать пятую тарелку снизу — нельзя, стопка рухнет.

Но `Stack` в Java наследует `Vector` (динамический массив) и получает **все** его методы:

```java
package com.ecommerce.realworld;

import java.util.ArrayDeque;
import java.util.Deque;
import java.util.Stack;

public class StackProblemDemo {

    public static void main(String[] args) {
        Stack<String> orderStack = new Stack<>();
        orderStack.push("ORD-001");  // Положили сверху — ОК
        orderStack.push("ORD-002");  // Положили сверху — ОК

        // А вот это — «выдернули тарелку из середины стопки».
        // Компилятор разрешает, потому что Stack IS-A Vector:
        orderStack.insertElementAt("ORD-HACKED", 0);  // Вставили в начало!
        orderStack.removeElementAt(1);                  // Удалили из середины!
        // Это больше не стек. Абстракция сломана.

        System.out.println("Stack after hacking: " + orderStack);

        // Правильный подход: Deque (интерфейс) + ArrayDeque
        Deque<String> properStack = new ArrayDeque<>();
        properStack.push("ORD-001");
        properStack.push("ORD-002");
        String top = properStack.pop();  // Только LIFO-операции
        System.out.println("Proper stack, popped: " + top);
        // insertElementAt? Такого метода у Deque нет — абстракция защищена.
    }
}
```

**Проблема:** `Stack` не «является» массивом (`Vector`). Стек — это абстракция с ограниченным набором операций. Наследование от `Vector` выставляет наружу операции, которые нарушают эту абстракцию.

**Правильное решение:** `Stack` должен был **содержать** массив внутри (композиция), а не наследовать его. Или быть интерфейсом, как `Deque`.

### Properties extends Hashtable

Похожая история: `Properties` предназначен для пар «строка — строка» (настройки приложения). Но он наследует `Hashtable<Object, Object>`:

```java
package com.ecommerce.realworld;

import java.util.Properties;

public class PropertiesProblemDemo {

    public static void main(String[] args) {
        Properties props = new Properties();
        props.setProperty("timeout", "30");  // String → String — ОК

        // Но Hashtable разрешает Object → Object:
        props.put("count", 100);  // Integer вместо String — компилируется!

        String timeout = props.getProperty("timeout");  // "30" — ОК
        String count = props.getProperty("count");       // null! Integer ≠ String
        System.out.println("timeout: " + timeout);
        System.out.println("count: " + count);  // null — сюрприз!

        // Баг обнаружится только в runtime.
        // Правильно было бы: Properties HAS-A Map<String, String>
    }
}
```

**Урок из обоих примеров:** Наследование ради «удобно, уже есть реализация» создаёт технический долг, который невозможно исправить из-за обратной совместимости. Композиция была бы безопаснее.

---

## 8.3 Тренд: от наследования к композиции

Java-экосистема в целом движется от наследования к композиции. Вот как это выглядит на примере веб-контроллеров (упрощённо, без привязки к конкретному фреймворку):

**Старый стиль — наследование:**

```java
// Контроллер наследует базовый класс фреймворка.
// Привязан к нему намертво. Тестировать сложно.
abstract class BaseController {
    abstract String handleRequest(String path);
}

class OrderController extends BaseController {
    @Override
    String handleRequest(String path) {
        return "Order page";
    }
}
```

**Современный стиль — композиция:**

```java
// Контроллер — обычный класс. Никакого наследования.
// Зависимости приходят через конструктор.
class OrderController {
    private final OrderService orderService;

    OrderController(OrderService orderService) {
        this.orderService = orderService;
    }

    String getOrder(String orderId) {
        return orderService.findById(orderId);
    }
}
```

Фреймворки (Spring, Micronaut, Quarkus) эволюционировали именно в этом направлении: от «наследуй наш базовый класс» к «напиши обычный класс, мы сами разберёмся».

---

## 8.4 Паттерн для своего проекта

Как спроектировать e-commerce систему, применяя всё, что мы изучили?

**Плохой дизайн — глубокая иерархия:**

```java
BaseModel
  └── AbstractEntity
        └── Order
              └── VipOrder
```

Четыре уровня. Изменение в `BaseModel` ломает всё. Тестировать `VipOrder` — значит тащить всю цепочку. Добавить `WholesaleOrder` — ещё один подкласс, ещё больше связанности.

**Хороший дизайн — композиция:**

```java
package com.ecommerce.realworld;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;
import java.util.Objects;

/**
 * Стратегия скидки — интерфейс.
 * Разное поведение — через разные реализации, не через наследование Order.
 */
interface DiscountStrategy {
    BigDecimal applyDiscount(BigDecimal subtotal);
    String name();
}

class NoDiscount implements DiscountStrategy {
    @Override
    public BigDecimal applyDiscount(BigDecimal subtotal) {
        return subtotal;
    }
    @Override
    public String name() { return "No discount"; }
}

class PercentageDiscount implements DiscountStrategy {
    private static final BigDecimal HUNDRED = new BigDecimal("100");
    private final BigDecimal percentage;

    PercentageDiscount(BigDecimal percentage) {
        this.percentage = Objects.requireNonNull(percentage);
    }

    @Override
    public BigDecimal applyDiscount(BigDecimal subtotal) {
        BigDecimal multiplier = BigDecimal.ONE.subtract(
            percentage.divide(HUNDRED, 4, RoundingMode.HALF_EVEN)
        );
        return subtotal.multiply(multiplier)
            .setScale(2, RoundingMode.HALF_EVEN);
    }

    @Override
    public String name() { return percentage + "% discount"; }
}

/**
 * Заказ — final класс. Никакого наследования.
 * Гибкость — через композицию: разные DiscountStrategy дают разное поведение.
 */
final class Order {
    private final String orderId;
    private final List<LineItem> items;
    private final DiscountStrategy discountStrategy;

    Order(String orderId, List<LineItem> items, DiscountStrategy discountStrategy) {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID required");
        }
        Objects.requireNonNull(items, "Items required");
        Objects.requireNonNull(discountStrategy, "Discount strategy required");
        if (items.isEmpty()) {
            throw new IllegalArgumentException("Order must have items");
        }

        this.orderId = orderId;
        this.items = List.copyOf(items);
        this.discountStrategy = discountStrategy;
    }

    BigDecimal calculateTotal() {
        BigDecimal subtotal = BigDecimal.ZERO;
        for (LineItem item : items) {
            subtotal = subtotal.add(item.lineTotal());
        }
        return discountStrategy.applyDiscount(subtotal);
    }

    String orderId() { return orderId; }
    List<LineItem> items() { return items; }
}

record LineItem(String productId, int quantity, BigDecimal price) {
    LineItem {
        if (productId == null || productId.isBlank()) {
            throw new IllegalArgumentException("Product ID required");
        }
        Objects.requireNonNull(price, "Price required");
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
        if (price.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Price must be non-negative");
        }
    }

    BigDecimal lineTotal() {
        return price.multiply(BigDecimal.valueOf(quantity));
    }
}
```

```java
package com.ecommerce.realworld;

import java.math.BigDecimal;
import java.util.List;

public class DesignPatternDemo {

    public static void main(String[] args) {
        List<LineItem> items = List.of(
            new LineItem("SKU-1", 2, new BigDecimal("50.00")),
            new LineItem("SKU-2", 1, new BigDecimal("30.00"))
        );
        // subtotal = 2×50 + 1×30 = 130.00

        // Обычный заказ — без скидки
        Order standard = new Order("ORD-1", items, new NoDiscount());
        System.out.println("Standard: " + standard.calculateTotal());
        // 130.00

        // VIP-заказ — 10% скидка. Тот же класс Order, другая стратегия.
        Order vip = new Order("ORD-2", items,
            new PercentageDiscount(new BigDecimal("10")));
        System.out.println("VIP (10% off): " + vip.calculateTotal());
        // 117.00

        // Добавить оптовую скидку? Новый класс WholesaleDiscount.
        // Order не меняется. Ни одна строка существующего кода не трогается.
    }
}
```

**Почему это лучше глубокой иерархии:**

- `Order` — `final`, никто не создаст `VipOrder extends Order`
- Разное поведение — через `DiscountStrategy`, не через наследование
- Добавить новую скидку = новый класс, ноль изменений в `Order`
- Тестирование: подставляем любую стратегию через конструктор

---

# 9. Типичные ошибки

## 9.1 Наследование ради переиспользования кода

Самая частая ловушка: «Мне нужен метод аудита в нескольких сервисах. Создам `BaseService` и буду наследовать».

```java
package com.ecommerce.antipatterns;

import java.util.Objects;

public class InheritanceForReuseDemo {

    // ❌ ПЛОХО: наследование ради общего метода audit()
    static abstract class BaseService {
        protected void audit(String action, String entityId) {
            System.out.println("[AUDIT] " + action + " " + entityId);
        }
    }

    // OrderService IS-A BaseService? Нет, это бессмысленная связь.
    static class OrderService extends BaseService {
        public void createOrder(String orderId) {
            System.out.println("Creating order: " + orderId);
            audit("CREATE_ORDER", orderId);
        }
    }

    // PaymentService тоже наследует BaseService.
    // А если ему нужна ещё одна «база»? Множественного наследования нет!
    static class PaymentService extends BaseService {
        public void processPayment(String paymentId) {
            System.out.println("Processing: " + paymentId);
            audit("PROCESS_PAYMENT", paymentId);
        }
    }

    // ✅ ХОРОШО: композиция через отдельный компонент
    static class AuditService {
        public void log(String action, String entityId) {
            System.out.println("[AUDIT] " + action + " " + entityId);
        }
    }

    static class OrderServiceV2 {
        private final AuditService audit;

        OrderServiceV2(AuditService audit) {
            this.audit = Objects.requireNonNull(audit);
        }

        public void createOrder(String orderId) {
            System.out.println("Creating order: " + orderId);
            audit.log("CREATE_ORDER", orderId);
        }
    }

    public static void main(String[] args) {
        System.out.println("=== Inheritance (bad) ===");
        new OrderService().createOrder("ORD-001");

        System.out.println("\n=== Composition (good) ===");
        new OrderServiceV2(new AuditService()).createOrder("ORD-002");
    }
}
```

**Проблемы наследования ради reuse:**

- `OrderService IS-A BaseService`? Нет. Связь бессмысленна.
- `BaseService` накапливает несвязанные методы (God Object)
- Нужна ещё одна «база» → множественного наследования нет
- Рефакторинг `BaseService` ломает все сервисы

**Правило:** Если связь не «является» (is-a), а «использует» (has-a) — это композиция, не наследование.

---

## 9.2 Утечка изменяемых ссылок

Геттер возвращает внутренний список напрямую → внешний код может изменить внутреннее состояние объекта.

```java
package com.ecommerce.antipatterns;

import java.util.ArrayList;
import java.util.List;
import java.util.Objects;

public class MutableLeakDemo {

    // ❌ ПЛОХО
    static class UnsafeOrder {
        private final List<String> items;

        UnsafeOrder(List<String> items) {
            this.items = items;  // сохраняем чужую ссылку
        }

        public List<String> getItems() {
            return items;  // отдаём свою ссылку наружу
        }
    }

    // ✅ ХОРОШО
    static class SafeOrder {
        private final List<String> items;

        SafeOrder(List<String> items) {
            // Defensive copy на ВХОДЕ
            this.items = List.copyOf(items);
        }

        public List<String> getItems() {
            // items уже unmodifiable (List.copyOf) — безопасно возвращать
            return items;
        }
    }

    public static void main(String[] args) {
        ArrayList<String> mutableList = new ArrayList<>(List.of("Keyboard", "Mouse"));

        // --- Unsafe ---
        UnsafeOrder unsafe = new UnsafeOrder(mutableList);
        System.out.println("Before: " + unsafe.getItems()); // [Keyboard, Mouse]

        mutableList.add("INJECTED");  // Через оригинальную ссылку
        System.out.println("After external add: " + unsafe.getItems());
        // [Keyboard, Mouse, INJECTED] — состояние заказа изменилось!

        unsafe.getItems().clear();  // Через геттер
        System.out.println("After getter clear: " + unsafe.getItems());
        // [] — заказ «пустой»!

        // --- Safe ---
        ArrayList<String> mutableList2 = new ArrayList<>(List.of("Keyboard", "Mouse"));
        SafeOrder safe = new SafeOrder(mutableList2);

        mutableList2.add("INJECTED");
        System.out.println("\nSafe after external add: " + safe.getItems());
        // [Keyboard, Mouse] — defensive copy защитила!

        try {
            safe.getItems().add("HACK");
        } catch (UnsupportedOperationException e) {
            System.out.println("Cannot mutate via getter ✅");
        }
    }
}
```

**Правило:** Если объект содержит коллекцию — делайте `List.copyOf()` в конструкторе. Это защитит от обеих атак: через оригинальную ссылку и через геттер.

---

## 9.3 Интерфейс: когда нужен, когда нет

Две крайности одинаково вредны.

**Крайность 1: интерфейс на каждый класс.**

```java
// Бессмысленный интерфейс с единственной реализацией:
interface IOrderValidator { boolean isValid(String orderId); }
class OrderValidatorImpl implements IOrderValidator { ... }
```

`IOrderService` → `OrderServiceImpl` — это не дизайн, это ритуал. Интерфейс 1:1 с реализацией не добавляет ценности, зато удваивает количество файлов.

**Крайность 2: ни одного интерфейса.**

```java
class OrderService {
    // Зависимость на конкретный класс — намертво.
    // В тесте придётся вызывать реальный Stripe API!
    private final StripeGateway gateway = new StripeGateway();

    public void checkout(String orderId) {
        gateway.charge(9999);  // HTTP-запрос в тесте? 😱
    }
}
```

**Когда интерфейс оправдан:**

- Есть или скоро будут несколько реализаций (Stripe, PayPal, тестовая заглушка)
- Зависимость на внешний сервис (БД, API, файловая система) — нужна возможность подставить заглушку в тестах
- Граница модуля: публичный контракт, за которым скрыта реализация

**Когда не нужен:**

- Единственная реализация внутри одного модуля
- Утилитарный класс без внешних зависимостей
- Единственная причина — «так принято»

```java
// Это ОК без интерфейса:
final class OrderValidator {
    boolean isValid(String orderId) {
        return orderId != null && orderId.startsWith("ORD-");
    }
}
```

---

## 9.4 Микрооптимизация вместо архитектуры

Коварная ошибка: разработчик узнаёт, что вызов через интерфейс (`invokeinterface`) чуть дороже прямого вызова, и начинает «оптимизировать» — убирает интерфейсы, делает всё `final`, заменяет полиморфизм на `switch`. Без единого замера.

**Что упускается:**

- JIT-компилятор HotSpot на типичном вызове де-виртуализирует интерфейсный вызов, превращая его в прямой. Разницы — ноль.
- Реальные тормоза в backend — это сеть, база данных, сериализация. Один запрос к PostgreSQL — миллисекунды. Разница в dispatch — наносекунды.
- Убирая интерфейс, вы **теряете** тестируемость, гибкость и соответствие SOLID.

**Правильный подход:**

```text
1. Написать код с интерфейсами (чистая архитектура)
2. Если есть проблема производительности — измерить
   (async-profiler, JFR, JMH)
3. Bottleneck — виртуальный вызов?
   └── Нет (99% случаев) → оптимизировать I/O, SQL, аллокации
   └── Да (tight loops, HFT) → помочь JIT: final, sealed, группировка по типу
```

Интерфейс — это не затрата. Это инвестиция в архитектуру.

---

## Итоги: правила на каждый день

| #   | Правило                                                             | Пример                                                      |
| --- | ------------------------------------------------------------------- | ----------------------------------------------------------- |
| 1   | Начинайте с композиции. Наследование — только для «является» (is-a) | `Order` **содержит** `DiscountStrategy`, а не наследует     |
| 2   | Программируйте на интерфейсе                                        | `List<String>`, не `ArrayList<String>`                      |
| 3   | Делайте defensive copy для коллекций                                | `List.copyOf(items)` в конструкторе                         |
| 4   | Интерфейс — когда есть реальная причина                             | Несколько реализаций, тестируемость, граница модуля         |
| 5   | Не оптимизируйте без измерений                                      | JIT справляется. Тормозит — I/O, не dispatch                |
| 6   | `final` по умолчанию                                                | Если класс не предназначен для наследования — запретите его |
| 7   | Всегда ставьте `@Override`                                          | Ловит ошибки при компиляции, а не в production              |
# 10. Best Practices

Правила из этого раздела — не догмы, а инструменты. Каждое имеет контекст и компромиссы. Применяйте с умом, а не вслепую.

---

## 10.1 `final` по умолчанию

Если класс не предназначен для наследования — сделайте его `final`. Это защищает инварианты, упрощает понимание кода и помогает JIT-компилятору (хотя и не гарантирует конкретных оптимизаций).

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Objects;

/**
 * Final класс: никто не создаст подкласс, нарушающий инварианты.
 *
 * Когда НЕ делать final:
 * - Skeletal implementations (AbstractList, AbstractPaymentProcessor)
 * - Классы, которые должны проксироваться фреймворком
 *   (Spring CGLIB-прокси не работают с final-классами,
 *    если нет интерфейса — учитывайте это)
 * - Осознанные extension points с документацией
 */
public final class Order {

    private final String orderId;
    private final List<LineItem> items;
    private final BigDecimal totalAmount;
    private final Instant createdAt;

    public Order(String orderId, List<LineItem> items) {
        if (orderId == null || orderId.isBlank()) {
            throw new IllegalArgumentException("Order ID required");
        }
        if (items == null || items.isEmpty()) {
            throw new IllegalArgumentException("Order must contain at least one item");
        }

        this.orderId = orderId;
        this.items = List.copyOf(items); // defensive copy
        this.createdAt = Instant.now();

        // Вычисляем total один раз при создании
        BigDecimal sum = BigDecimal.ZERO;
        for (LineItem item : items) {
            sum = sum.add(item.subtotal());
        }
        this.totalAmount = sum;
    }

    public String getOrderId() { return orderId; }
    public List<LineItem> getItems() { return items; }
    public BigDecimal getTotalAmount() { return totalAmount; }
    public Instant getCreatedAt() { return createdAt; }

    @Override
    public String toString() {
        return "Order{id='%s', items=%d, total=%s}"
            .formatted(orderId, items.size(), totalAmount);
    }
}
```

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;
import java.util.Objects;

/**
 * Record — final по определению. Идеален для value objects.
 */
public record LineItem(
        String productId,
        String productName,
        int quantity,
        BigDecimal price
) {
    public LineItem {
        if (productId == null || productId.isBlank()) {
            throw new IllegalArgumentException("Product ID required");
        }
        if (productName == null || productName.isBlank()) {
            throw new IllegalArgumentException("Product name required");
        }
        Objects.requireNonNull(price, "Price required");
        if (quantity <= 0) {
            throw new IllegalArgumentException("Quantity must be positive");
        }
        if (price.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("Price must be non-negative");
        }
    }

    public BigDecimal subtotal() {
        return price.multiply(BigDecimal.valueOf(quantity));
    }
}
```

---

## 10.2 Документировать extension points

Если класс **не** `final` — он должен быть спроектирован и задокументирован для наследования. Иначе подклассы рано или поздно сломаются.

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;
import java.util.Objects;

/**
 * Template Method: базовый класс определяет скелет алгоритма,
 * подклассы реализуют конкретные шаги.
 *
 * Правила:
 * 1. process() — final. Подклассы не меняют порядок шагов.
 * 2. executeTransaction() — единственная точка расширения.
 * 3. Конструктор НЕ вызывает переопределяемых методов.
 *
 * Потокобезопасность: реализации должны быть stateless
 * или обеспечивать синхронизацию самостоятельно.
 */
public abstract class AbstractPaymentProcessor {

    private static final BigDecimal MAX_AMOUNT = new BigDecimal("1000000");

    /**
     * Обработка платежа — фиксированный порядок шагов.
     */
    public final boolean process(BigDecimal amount) {
        validate(amount);
        boolean result = executeTransaction(amount);
        logResult(amount, result);
        return result;
    }

    private void validate(BigDecimal amount) {
        if (amount == null || amount.compareTo(BigDecimal.ZERO) <= 0) {
            throw new IllegalArgumentException("Amount must be positive");
        }
        if (amount.compareTo(MAX_AMOUNT) > 0) {
            throw new IllegalArgumentException("Amount exceeds limit");
        }
    }

    /**
     * Единственная точка расширения.
     *
     * Контракт:
     * - Выполнить списание через конкретный провайдер
     * - Вернуть true при успехе, false при отказе
     * - Не вызывать process() (рекурсия!)
     *
     * @param amount валидированная сумма (> 0, <= 1_000_000)
     */
    protected abstract boolean executeTransaction(BigDecimal amount);

    private void logResult(BigDecimal amount, boolean success) {
        String status = success ? "OK" : "FAILED";
        System.out.printf("[%s] Payment %s: %s%n",
            getClass().getSimpleName(), status, amount);
    }
}
```

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;

/**
 * Конкретная реализация — final.
 * Дальше наследовать нельзя.
 */
public final class StripeProcessor extends AbstractPaymentProcessor {

    @Override
    protected boolean executeTransaction(BigDecimal amount) {
        // В реальности: HTTP-вызов к Stripe API
        System.out.println("  Stripe: charging " + amount);
        return true;
    }
}
```

---

## 10.3 Records для DTO и value objects

Record — идеальный инструмент для объектов, которые представляют **данные**, а не поведение: DTO, события, результаты запросов, value objects.

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.List;
import java.util.Objects;

// DTO для ответа API
public record OrderSummary(
        String orderId,
        BigDecimal total,
        String status,
        Instant createdAt
) {
    public OrderSummary {
        Objects.requireNonNull(orderId, "orderId required");
        Objects.requireNonNull(total, "total required");
        Objects.requireNonNull(status, "status required");
        Objects.requireNonNull(createdAt, "createdAt required");
    }
}

// Событие для очереди сообщений
public record PaymentProcessed(
        String paymentId,
        String orderId,
        BigDecimal amount,
        String providerName,
        Instant processedAt
) {
    public PaymentProcessed {
        Objects.requireNonNull(paymentId, "paymentId required");
        Objects.requireNonNull(orderId, "orderId required");
        Objects.requireNonNull(amount, "amount required");
        Objects.requireNonNull(providerName, "providerName required");
        Objects.requireNonNull(processedAt, "processedAt required");
    }
}

// Value object с коллекцией — обязательная defensive copy
public record OrderDetails(
        String orderId,
        List<LineItem> items,
        BigDecimal total
) {
    public OrderDetails {
        Objects.requireNonNull(orderId, "orderId required");
        Objects.requireNonNull(items, "items required");
        Objects.requireNonNull(total, "total required");
        items = List.copyOf(items); // неизменяемая копия
    }
}
```

> **Осторожно с `toString()`.** Record генерирует `toString()` со **всеми** компонентами. Если record содержит email, токен или другие чувствительные данные — они попадут в логи. Переопределяйте `toString()` вручную в таких случаях.

> **Осторожно с `equals()` и `BigDecimal`.** Record-овский `equals()` использует `BigDecimal.equals()`, который учитывает scale: `new BigDecimal("100.0")` ≠ `new BigDecimal("100.00")`. Если record используется как ключ в `HashMap` — это источник багов. Нормализуйте scale в compact-конструкторе.

---

## 10.4 Sealed для контролируемых иерархий

Когда набор подтипов **фиксирован** и контролируется вами — используйте `sealed`. Компилятор проверит, что все варианты обработаны.

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.Objects;

public sealed interface OrderEvent permits
        OrderEvent.Created,
        OrderEvent.Paid,
        OrderEvent.Shipped,
        OrderEvent.Delivered,
        OrderEvent.Cancelled {

    String orderId();
    Instant timestamp();

    record Created(String orderId, Instant timestamp, String customerId)
        implements OrderEvent {
        public Created {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(customerId);
        }
    }

    record Paid(String orderId, Instant timestamp, String paymentId, BigDecimal amount)
        implements OrderEvent {
        public Paid {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(paymentId);
            Objects.requireNonNull(amount);
        }
    }

    record Shipped(String orderId, Instant timestamp, String trackingNumber)
        implements OrderEvent {
        public Shipped {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(trackingNumber);
        }
    }

    record Delivered(String orderId, Instant timestamp, String signedBy)
        implements OrderEvent {
        public Delivered {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
        }
    }

    record Cancelled(String orderId, Instant timestamp, String reason)
        implements OrderEvent {
        public Cancelled {
            Objects.requireNonNull(orderId);
            Objects.requireNonNull(timestamp);
            Objects.requireNonNull(reason);
        }
    }
}
```

Обработка — exhaustive switch (Java 21):

```java
package com.ecommerce.bestpractices;

public final class OrderEventHandler {

    /**
     * Компилятор ТРЕБУЕТ обработать все варианты.
     * Добавите новый record в sealed interface →
     * ошибка компиляции здесь, пока не добавите case.
     */
    public String handle(OrderEvent event) {
        if (event == null) {
            throw new IllegalArgumentException("Event must not be null");
        }

        return switch (event) {
            case OrderEvent.Created e ->
                "New order " + e.orderId() + " from " + e.customerId();
            case OrderEvent.Paid e ->
                "Order " + e.orderId() + " paid: " + e.amount();
            case OrderEvent.Shipped e ->
                "Order " + e.orderId() + " shipped, tracking: " + e.trackingNumber();
            case OrderEvent.Delivered e ->
                "Order " + e.orderId() + " delivered"
                    + (e.signedBy() != null ? ", signed by " + e.signedBy() : "");
            case OrderEvent.Cancelled e ->
                "Order " + e.orderId() + " cancelled: " + e.reason();
        };
    }
}
```

**Когда sealed НЕ подходит:**

- Нужна расширяемость извне (плагины, SPI, внешние интеграции)
- Набор подтипов часто меняется (каждый sealed-switch придётся обновлять)
- Тестовые подтипы: тест не может создать свою реализацию sealed-интерфейса

---

## 10.5 Маленькие интерфейсы + стратегии

Вместо одного интерфейса с 20 методами — несколько маленьких, каждый с одной ответственностью. Вместо глубокой иерархии наследования — стратегии через композицию.

```java
package com.ecommerce.bestpractices;

import java.math.BigDecimal;
import java.math.RoundingMode;
import java.util.List;
import java.util.Objects;

/**
 * Маленький интерфейс — одна ответственность.
 */
public interface DiscountStrategy {
    BigDecimal applyDiscount(BigDecimal subtotal);
    String name();
}

// Стратегия 1: без скидки (Null Object pattern)
final class NoDiscount implements DiscountStrategy {
    @Override
    public BigDecimal applyDiscount(BigDecimal subtotal) {
        return subtotal;
    }
    @Override
    public String name() { return "No discount"; }
}

// Стратегия 2: процентная скидка
final class PercentageDiscount implements DiscountStrategy {
    private static final BigDecimal HUNDRED = new BigDecimal("100");
    private final BigDecimal percentage;
    private final BigDecimal multiplier; // вычисляем один раз

    PercentageDiscount(BigDecimal percentage) {
        Objects.requireNonNull(percentage, "Percentage required");
        if (percentage.compareTo(BigDecimal.ZERO) < 0
                || percentage.compareTo(HUNDRED) > 0) {
            throw new IllegalArgumentException("Percentage must be 0–100");
        }
        this.percentage = percentage;
        this.multiplier = BigDecimal.ONE.subtract(
            percentage.divide(HUNDRED, 4, RoundingMode.HALF_EVEN)
        );
    }

    @Override
    public BigDecimal applyDiscount(BigDecimal subtotal) {
        Objects.requireNonNull(subtotal, "Subtotal required");
        return subtotal.multiply(multiplier)
            .setScale(2, RoundingMode.HALF_EVEN);
    }

    @Override
    public String name() { return percentage + "% discount"; }
}

// Стратегия 3: композитная (цепочка стратегий)
final class CompositeDiscount implements DiscountStrategy {
    private final List<DiscountStrategy> strategies;

    CompositeDiscount(List<DiscountStrategy> strategies) {
        Objects.requireNonNull(strategies, "Strategies required");
        for (DiscountStrategy s : strategies) {
            Objects.requireNonNull(s, "Strategy must not be null");
        }
        this.strategies = List.copyOf(strategies);
    }

    @Override
    public BigDecimal applyDiscount(BigDecimal subtotal) {
        BigDecimal result = subtotal;
        for (DiscountStrategy strategy : strategies) {
            result = strategy.applyDiscount(result);
        }
        return result;
    }

    @Override
    public String name() { return "Composite discount"; }
}
```

---

## 10.6 Производительность: приоритеты

Оптимизация — это не про наносекунды dispatch. Вот приоритеты, начиная с самого важного:

**1. Архитектура** — правильные структуры данных, минимизация I/O (batch-запросы к БД, connection pooling, кэширование), ленивая загрузка. Здесь — основной выигрыш.

**2. Аллокации** — переиспользование объектов где безопасно (`StringBuilder`), примитивные типы вместо обёрток в горячих путях, константы вместо `new BigDecimal("0.95")` на каждом вызове.

**3. JIT-подсказки** — `final` классы/методы, `sealed` интерфейсы. Помогают, но не гарантируют конкретных оптимизаций.

**4. Микрооптимизации** — замена интерфейса на конкретный класс, ручной цикл вместо Stream API. **Не делайте без измерений** (JMH, async-profiler, JFR).

> **Правило:** Тратьте 80% усилий на архитектуру, 15% на аллокации, 5% на остальное. Сначала измеряйте — потом оптимизируйте.

---

## Чеклист

| ✅   | Практика                                                               |
| --- | ---------------------------------------------------------------------- |
| ☐   | Классы `final` по умолчанию (с учётом совместимости с фреймворками)    |
| ☐   | Наследование — осознанно, с документацией extension points             |
| ☐   | Records для DTO, событий, value objects                                |
| ☐   | `List.copyOf()` в конструкторах для коллекций                          |
| ☐   | Sealed для фиксированных иерархий (где не нужна внешняя расширяемость) |
| ☐   | Маленькие интерфейсы + стратегии вместо глубоких деревьев              |
| ☐   | Композиция > наследование                                              |
| ☐   | `@Override` на каждом переопределении                                  |
| ☐   | `toString()` без чувствительных данных                                 |
| ☐   | Не оптимизировать без измерений                                        |

---

# 11. Заключение

Мы прошли путь от первого `new Order(...)` до production-паттернов:

**Класс и объект** — шаблон и его экземпляр. Каждый `new` создаёт объект в куче, ссылка на него живёт на стеке.

**Инкапсуляция** — не просто `private`. Это контролируемый доступ, который защищает инварианты: defensive copy, неизменяемые возвраты, валидация в конструкторе.

**Наследование** — мощный, но опасный инструмент. Поля базового класса физически присутствуют в каждом подклассе. Главная ловушка: вызов переопределяемого метода из конструктора → обращение к неинициализированным полям подкласса.

**Полиморфизм** — ядро ООП. Один интерфейс, разные реализации. JVM определяет нужный метод в runtime. JIT-компилятор в большинстве случаев оптимизирует виртуальный вызов до прямого.

**Композиция > наследование** — не слоган, а инженерное решение. Зависимости через конструктор, стратегии через интерфейсы, `final` классы по умолчанию.

**Современная Java (17–21)** — records для данных, sealed для контролируемых иерархий, pattern matching для обработки вариантов.

### Правила на каждый день

1. **Начинайте с композиции.** Наследование — только для «является» (is-a).
2. **Программируйте на интерфейсе.** `List<String>`, не `ArrayList<String>`.
3. **Делайте defensive copy** для коллекций в конструкторах.
4. **`final` по умолчанию.** Открывайте для наследования осознанно.
5. **Всегда `@Override`.** Ошибки — при компиляции, не в production.
6. **Не оптимизируйте без измерений.** Тормозит — I/O, не dispatch.
7. **Валидируйте входы в конструкторе.** Fail fast — лучше, чем NPE через 500 строк.

