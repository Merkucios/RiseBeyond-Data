# Переменные в Java — от Hello World до Production

> **Для кого эта статья:** вы написали свой первый `System.out.println("Hello World!");` и хотите разобраться, как Java работает с данными. Мы начнём с самых основ, и к концу статьи вы будете понимать, как пишут код в серьёзных проектах. Каждый раздел сложнее предыдущего — и это нормально. Если какой-то раздел кажется непонятным, пропустите его и вернитесь позже.

---

## Оглавление

- [Раздел 1: Концепт](#%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%201:%20%D0%9A%D0%BE%D0%BD%D1%86%D0%B5%D0%BF%D1%82)
	- [Переменные — это ящики на складе](#%D0%9F%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5%20%E2%80%94%20%D1%8D%D1%82%D0%BE%20%D1%8F%D1%89%D0%B8%D0%BA%D0%B8%20%D0%BD%D0%B0%20%D1%81%D0%BA%D0%BB%D0%B0%D0%B4%D0%B5)
	- [Как Java развивалась](#%D0%9A%D0%B0%D0%BA%20Java%20%D1%80%D0%B0%D0%B7%D0%B2%D0%B8%D0%B2%D0%B0%D0%BB%D0%B0%D1%81%D1%8C)
- [Раздел 2: Hello World](#%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%202:%20Hello%20World)
	- [Четыре вида переменных](#%D0%A7%D0%B5%D1%82%D1%8B%D1%80%D0%B5%20%D0%B2%D0%B8%D0%B4%D0%B0%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
	- [Ключевое слово `final`: пломба на ящике](#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5%20%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%C2%A0%60final%60:%20%D0%BF%D0%BB%D0%BE%D0%BC%D0%B1%D0%B0%20%D0%BD%D0%B0%20%D1%8F%D1%89%D0%B8%D0%BA%D0%B5)
	- [Ключевое слово `var` (Java 10+)](#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5%20%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%C2%A0%60var%60%C2%A0(Java%2010+))
	- [Типы данных: что можно положить в ящик](#%D0%A2%D0%B8%D0%BF%D1%8B%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85:%20%D1%87%D1%82%D0%BE%20%D0%BC%D0%BE%D0%B6%D0%BD%D0%BE%20%D0%BF%D0%BE%D0%BB%D0%BE%D0%B6%D0%B8%D1%82%D1%8C%20%D0%B2%20%D1%8F%D1%89%D0%B8%D0%BA)
- [Раздел 3: Под капотом](#%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%203:%20%D0%9F%D0%BE%D0%B4%20%D0%BA%D0%B0%D0%BF%D0%BE%D1%82%D0%BE%D0%BC)
	- [Память: Stack и Heap](#%D0%9F%D0%B0%D0%BC%D1%8F%D1%82%D1%8C:%20Stack%20%D0%B8%20Heap)
	- [Что генерирует компилятор](#%D0%A7%D1%82%D0%BE%20%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D1%83%D0%B5%D1%82%20%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80)
	- [Ключевое слово `final` для полей: гарантии для многопоточности](#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D0%BE%D0%B5%20%D1%81%D0%BB%D0%BE%D0%B2%D0%BE%C2%A0%60final%60%C2%A0%D0%B4%D0%BB%D1%8F%20%D0%BF%D0%BE%D0%BB%D0%B5%D0%B9:%20%D0%B3%D0%B0%D1%80%D0%B0%D0%BD%D1%82%D0%B8%D0%B8%20%D0%B4%D0%BB%D1%8F%20%D0%BC%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D0%B8)
	- [Effectively final и лямбды](#Effectively%20final%20%D0%B8%20%D0%BB%D1%8F%D0%BC%D0%B1%D0%B4%D1%8B)
- [Раздел 4: Production Grade](#%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%204:%20Production%20Grade)
	- [4.1. Именование переменных](#4.1.%20%D0%98%D0%BC%D0%B5%D0%BD%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85)
	- [4.2. Использование `final`](#4.2.%20%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%C2%A0%60final%60)
	- [4.3. Константы: правильная организация](#4.3.%20%D0%9A%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82%D1%8B:%20%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%B0%D1%8F%20%D0%BE%D1%80%D0%B3%D0%B0%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F)
	- [4.4. `var`: когда использовать, а когда — нет](#4.4.%C2%A0%60var%60:%20%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D1%82%D1%8C,%20%D0%B0%20%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0%20%E2%80%94%20%D0%BD%D0%B5%D1%82)
	- [4.5. Безопасное логирование](#4.5.%20%D0%91%D0%B5%D0%B7%D0%BE%D0%BF%D0%B0%D1%81%D0%BD%D0%BE%D0%B5%20%D0%BB%D0%BE%D0%B3%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
	- [4.6. Records: неизменяемые данные (Java 16+)](#4.6.%20Records:%20%D0%BD%D0%B5%D0%B8%D0%B7%D0%BC%D0%B5%D0%BD%D1%8F%D0%B5%D0%BC%D1%8B%D0%B5%20%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D0%B5%20(Java%2016+))
	- [4.7. Многопоточность: когда нужна защита](#4.7.%20%D0%9C%D0%BD%D0%BE%D0%B3%D0%BE%D0%BF%D0%BE%D1%82%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C:%20%D0%BA%D0%BE%D0%B3%D0%B4%D0%B0%20%D0%BD%D1%83%D0%B6%D0%BD%D0%B0%20%D0%B7%D0%B0%D1%89%D0%B8%D1%82%D0%B0)
	- [4.8. Тестирование](#4.8.%20%D0%A2%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5)
- [Раздел 5: Грабли](#%D0%A0%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%205:%20%D0%93%D1%80%D0%B0%D0%B1%D0%BB%D0%B8)
	- [5.1. `var` с `null`](#5.1.%C2%A0%60var%60%C2%A0%D1%81%C2%A0%60null%60)
	- [5.2. Shadowing: переменная прячет переменную](#5.2.%20Shadowing:%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D0%B0%D1%8F%20%D0%BF%D1%80%D1%8F%D1%87%D0%B5%D1%82%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%83%D1%8E)
	- [5.3. Использование до инициализации](#5.3.%20%D0%98%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%20%D0%B4%D0%BE%20%D0%B8%D0%BD%D0%B8%D1%86%D0%B8%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D0%B8)
	- [5.4. `final` для ссылочных типов](#5.4.%C2%A0%60final%60%C2%A0%D0%B4%D0%BB%D1%8F%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D1%87%D0%BD%D1%8B%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
	- [5.5. Видимость переменных в блоках](#5.5.%20%D0%92%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C%20%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D1%85%20%D0%B2%20%D0%B1%D0%BB%D0%BE%D0%BA%D0%B0%D1%85)
	- [5.6. Pattern Matching: область видимости (Java 16+)](#5.6.%20Pattern%20Matching:%20%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D1%8C%20%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8%20(Java%2016+))
	- [5.7. Массивы и `final`](#5.7.%20%D0%9C%D0%B0%D1%81%D1%81%D0%B8%D0%B2%D1%8B%20%D0%B8%C2%A0%60final%60)
	- [5.8. Точность дробных чисел](#5.8.%20%D0%A2%D0%BE%D1%87%D0%BD%D0%BE%D1%81%D1%82%D1%8C%20%D0%B4%D1%80%D0%BE%D0%B1%D0%BD%D1%8B%D1%85%20%D1%87%D0%B8%D1%81%D0%B5%D0%BB)
	- [5.9. Утечки через static-переменные](#5.9.%20%D0%A3%D1%82%D0%B5%D1%87%D0%BA%D0%B8%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20static-%D0%BF%D0%B5%D1%80%D0%B5%D0%BC%D0%B5%D0%BD%D0%BD%D1%8B%D0%B5)
- [Приложения](#%D0%9F%D1%80%D0%B8%D0%BB%D0%BE%D0%B6%D0%B5%D0%BD%D0%B8%D1%8F)
	- [Чеклист для code review](#%D0%A7%D0%B5%D0%BA%D0%BB%D0%B8%D1%81%D1%82%20%D0%B4%D0%BB%D1%8F%20code%20review)
	- [Таблица примитивных типов](#%D0%A2%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0%20%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%BD%D1%8B%D1%85%20%D1%82%D0%B8%D0%BF%D0%BE%D0%B2)
	- [Ссылки](#%D0%A1%D1%81%D1%8B%D0%BB%D0%BA%D0%B8)


---

## Раздел 1: Концепт

### Переменные — это ящики на складе

Представьте большой склад. На нём стоят ящики, и в каждом лежит что-то полезное: число, текст, дата. На каждом ящике — этикетка с названием и типом содержимого.

Вот и всё. **Переменная в Java — это именованный ящик для хранения данных.**

Но ящики бывают разные:

| Тип ящика                | Аналогия                                                                          | В Java                         |
| ------------------------ | --------------------------------------------------------------------------------- | ------------------------------ |
| **Локальная переменная** | Временный ящик на рабочем столе. Пока вы работаете — он здесь. Ушли — ящик исчез. | Переменная внутри метода       |
| **Instance-переменная**  | Личный ящик сотрудника. У каждого сотрудника — свой набор ящиков.                 | Поле объекта (без `static`)    |
| **Static-переменная**    | Общий ящик на весь офис. Один на всех.                                            | Поле класса со словом `static` |
| **`final`-переменная**   | Опечатанный ящик с пломбой. Положили содержимое один раз — больше не меняем.      | Переменная со словом `final`   |

### Как Java развивалась

Java не стоит на месте. Со временем работа с переменными становилась удобнее:

- **До Java 10:** на каждом ящике нужна подробная этикетка — `ArrayList<String> list = new ArrayList<String>();`
- **Java 10+:** появилось слово `var` — склад сам определяет тип по содержимому: `var list = new ArrayList<String>();`
- **Java 16+:** Pattern Matching — автоматическая распаковка ящика при проверке типа

---

## Раздел 2: Hello World

### Четыре вида переменных


```java
public class VariableDemo {

    // Static-переменная: одна на весь класс (общий ящик на офис)
    static int totalEmployees = 100;

    // Instance-переменная: у каждого объекта своя (личный ящик сотрудника)
    String name;

    public void process(int age) {   // age — параметр метода
        // Локальная переменная: живёт только внутри этого метода
        int yearsToRetirement = 65 - age;
        System.out.println(name + " выйдет на пенсию через " + yearsToRetirement + " лет");
    }
}
```

Давайте разберём каждую строку:

- `static int totalEmployees = 100;` — общее количество сотрудников. Оно не привязано к конкретному объекту. Создадите вы десять объектов `VariableDemo` или ни одного — `totalEmployees` всё равно один.
- `String name;` — имя конкретного сотрудника. Если мы создадим два объекта, у каждого будет своё `name`.
- `int age` — параметр метода. Он работает как локальная переменная: появляется при вызове метода и исчезает, когда метод завершился.
- `int yearsToRetirement` — локальная переменная. Она существует только внутри фигурных скобок метода `process`.

### Ключевое слово `final`: пломба на ящике

Когда вы пишете `final`, вы говорите: **«Это значение больше не изменится».**


```java
final int maxUsers = 1000;
maxUsers = 2000; // Ошибка компиляции! Нельзя менять значение.
```

Компилятор Java просто не даст вам скомпилировать такой код. Это защита от случайных ошибок: если вы знаете, что число не должно меняться, скажите об этом Java, и она проследит за вами.

### Ключевое слово `var` (Java 10+)

`var` — это сокращённая запись. Вместо того чтобы писать тип дважды, вы позволяете компилятору вычислить его за вас:

```java
// Без var — тип написан дважды:
String message = "Hello";
int count = 42;
ArrayList<String> list = new ArrayList<String>();

// С var — тип пишем один раз (справа), а слева var:
var message = "Hello";       // компилятор понимает: это String
var count = 42;              // компилятор понимает: это int
var list = new ArrayList<String>(); // компилятор понимает: это ArrayList<String>
```

**Важно:** `var` — это **не** динамическая типизация. Тип определяется один раз при компиляции и больше не меняется. Это просто способ писать короче.

### Типы данных: что можно положить в ящик

В Java есть восемь **примитивных типов** — это самые базовые «ящики»:

| Тип       | Что хранит                           | Пример                           |
| --------- | ------------------------------------ | -------------------------------- |
| `int`     | Целое число                          | `int age = 25;`                  |
| `long`    | Большое целое число                  | `long population = 8000000000L;` |
| `double`  | Дробное число                        | `double price = 9.99;`           |
| `float`   | Дробное число (менее точное)         | `float temperature = 36.6f;`     |
| `boolean` | Да или нет                           | `boolean isActive = true;`       |
| `char`    | Один символ                          | `char grade = 'A';`              |
| `byte`    | Маленькое целое число (−128..127)    | `byte level = 5;`                |
| `short`   | Целое число побольше (−32768..32767) | `short port = 8080;`             |

Всё остальное — **ссылочные типы**: строки (`String`), массивы, любые объекты. О разнице между примитивами и ссылками мы поговорим в следующем разделе.

---

## Раздел 3: Под капотом

> **Уровень сложности: средний.** Этот раздел объясняет, как Java устроена внутри. Если вы только начали изучать язык, можете пропустить его и вернуться через пару недель.

### Память: Stack и Heap

Когда ваша программа работает, Java использует два типа памяти:

**Stack (стек)** — быстрая память, организованная как стопка тарелок. Каждый метод кладёт свою «тарелку» наверх стопки, а когда метод завершается — тарелка снимается. На этой тарелке лежат локальные переменные метода.

**Heap (куча)** — большая общая память. Здесь живут объекты, которые вы создаёте через `new`.

```java
STACK                              HEAP
(у каждого потока свой)            (общая на всю программу)
┌───────────────────┐              ┌──────────────────────┐
│ int age = 25      │              │ объект User          │
│ ссылка user ──────┼─────────────►│   name: "Alice"      │
│ int x = 10        │              │   age: 25            │
└───────────────────┘              └──────────────────────┘
```

Вот что здесь происходит:

- `int age = 25` — примитив, хранится прямо в стеке. Быстро и просто.
- `user` — ссылочная переменная. В стеке хранится только **адрес** (ссылка), а сам объект `User` лежит в куче.
- Когда метод завершается, стековый кадр удаляется. Переменные `age` и `user` исчезают. Но объект `User` в куче продолжает жить, пока на него кто-то ссылается.

**Где что хранится:**

|Что|Где|
|---|---|
|Локальные примитивы (`int x = 10`)|Stack|
|Локальные ссылки (`User user = ...`)|Ссылка — в stack, объект — в heap|
|Поля объекта (instance-переменные)|Heap (внутри объекта)|
|Static-переменные|В структурах, связанных с объектом `Class` в heap|

### Что генерирует компилятор

Когда вы пишете Java-код, компилятор `javac` превращает его в **байт-код** — набор инструкций для виртуальной машины Java (JVM). Это промежуточный формат между вашим кодом и машинными инструкциями процессора.

Вот упрощённый пример. Когда вы пишете:


```java
int x = 10;
```

Компилятор генерирует примерно такие инструкции (упрощённо):


```java
bipush 10    // положить число 10 на стек операндов
istore_1     // сохранить значение в слот локальной переменной №1
```

А теперь самое интересное. Когда вы пишете:

```java
var x = 10;
```

Компилятор генерирует **абсолютно такой же** байт-код. Слово `var` существует только в исходном коде. После компиляции от него не остаётся следа — JVM даже не знает, что вы его использовали.

### Ключевое слово `final` для полей: гарантии для многопоточности

> Этот подраздел затрагивает тему многопоточности. Если вы пока не знакомы с потоками (threads), достаточно запомнить одно: **помечайте переменные словом `final`, если их значение не должно меняться.** Детали станут понятны позже.

Когда несколько потоков (то есть несколько частей программы, работающих одновременно) обращаются к одним и тем же данным, могут возникнуть проблемы. Один поток записал значение, а другой его не увидел, потому что процессор закешировал старое значение.

Для полей класса `final` даёт важную гарантию: если объект создан правильно (через конструктор), то все потоки увидят корректные значения `final`-полей. Это часть **модели памяти Java (Java Memory Model, JMM)** — набора правил, определяющих, когда изменения, сделанные одним потоком, становятся видимы другим.

Для **локальных** переменных и параметров методов `final` такой роли не играет — они и так доступны только одному потоку. Но `final` для них полезен по другой причине: он защищает от случайного переназначения.

### Effectively final и лямбды

Вы встретите термин **effectively final**, когда начнёте использовать лямбда-выражения или анонимные классы. Вот простой пример:

```java
int x = 10; // не объявлена как final, но значение нигде не меняется
Runnable r = () -> System.out.println(x); // лямбда использует x
```

Переменная `x` — **effectively final**: она не помечена словом `final`, но её значение ни разу не меняется после инициализации. Java разрешает использовать такие переменные в лямбдах.

Почему? Потому что лямбда **копирует** значение `x` в себя. Если бы `x` могла измениться после копирования, лямбда работала бы с устаревшим значением. Чтобы не допустить такого рассинхрона, Java требует, чтобы переменная была `final` или effectively final.

---

## Раздел 4: Production Grade

> **Уровень сложности: выше среднего.** Здесь собраны практики, которые используют в реальных проектах. Если вы только начали изучать Java, прочитайте подраздел про именование (4.1) — он пригодится сразу. Остальное можно отложить.

### 4.1. Именование переменных

Имя переменной — это самая важная документация. Хорошее имя делает код понятным без комментариев.

**Плохо:**

```java
int d;                    // Что это? День? Дата? Задержка? Расстояние?
String s1, s2;            // Совершенно непонятно
final int DELAY = 3;     // 3 чего? Секунд? Минут? Миллисекунд?

public void process() {
    if (d > 100) {        // Что означает 100?
        // ...
    }
}
```

**Хорошо:**

```java
int daysUntilExpiration;
String firstName;
String lastName;

// Единица измерения — в названии
private static final int CONNECTION_TIMEOUT_MS = 3000;

// Boolean-переменные начинаются с is/has/can/should
boolean isActive;
boolean hasPermission;
boolean canExecute;

// Коллекции — во множественном числе
List<User> activeUsers;
Map<String, Order> ordersByUserId;
```

**Основные правила:**

| Что                        | Как называть                          | Пример                          |
| -------------------------- | ------------------------------------- | ------------------------------- |
| Обычные переменные         | `camelCase`                           | `firstName`, `orderCount`       |
| Константы (`static final`) | `UPPER_SNAKE_CASE`                    | `MAX_RETRY_ATTEMPTS`            |
| Boolean                    | Префиксы `is`, `has`, `can`, `should` | `isValid`, `hasErrors`          |
| Коллекции                  | Множественное число                   | `users`, `orders`, `items`      |
| Map                        | `*By*`                                | `usersByEmail`, `ordersByDate`  |
| Время                      | Суффикс с единицей                    | `timeoutMillis`, `delaySeconds` |
| Границы                    | Префиксы `max`, `min`                 | `maxSize`, `minValue`           |

### 4.2. Использование `final`

Помечайте переменные словом `final`, если их значение не должно меняться. Это не магия производительности, а **инструмент коммуникации**: вы говорите тому, кто читает ваш код (и самому себе через полгода): «Эта переменная не переназначается».

```java
public class UserService {

    // Logger: private static final — стандартный паттерн
    private static final Logger log = LoggerFactory.getLogger(UserService.class);

    // Константа класса
    public static final int DEFAULT_RETRY_COUNT = 3;

    // Поля объекта: final означает, что после создания объекта значение не изменится
    private final String userId;
    private final LocalDate registrationDate;

    public UserService(String userId) {
        if (userId == null || userId.isBlank()) {
            throw new IllegalArgumentException("userId cannot be null or blank");
        }
        this.userId = userId;
        this.registrationDate = LocalDate.now();
    }

    // Параметры и локальные переменные: final защищает от случайного переназначения
    public int calculateAccountAgeDays(final LocalDate currentDate) {
        final Period period = Period.between(this.registrationDate, currentDate);
        final int totalDays = period.getYears() * 365 + period.getMonths() * 30 + period.getDays();
        return totalDays;
    }

    // final в условных блоках: компилятор проверит, что все ветки инициализируют переменную
    public String getUserStatus(final int accountAgeDays) {
        final String status;

        if (accountAgeDays < 30) {
            status = "NEW";
        } else if (accountAgeDays < 365) {
            status = "ACTIVE";
        } else {
            status = "VETERAN";
        }

        return status; // компилятор гарантирует, что status инициализирована
    }

    public String getUserId() {
        return userId;
    }

    public LocalDate getRegistrationDate() {
        return registrationDate;
    }
}
```

**Зачем `final`:**

- **Для полей объекта** — гарантия неизменности после создания, важна для многопоточности (JMM даёт гарантию видимости `final`-полей).
- **Для локальных переменных** — защита от случайного переназначения, улучшение читаемости.
- **Для параметров метода** — страховка от ошибок вида `параметр = что-то другое`.

**Чего `final` не делает:**

- Не делает объект неизменяемым. `final List<String> items` запрещает переназначить ссылку, но не запрещает вызвать `items.add(...)`.
- Не ускоряет код волшебным образом. JIT-компилятор и без `final` способен оптимизировать локальные переменные — он анализирует поток данных, а не модификаторы.

### 4.3. Константы: правильная организация

```java
import java.time.Duration;

public final class AppConstants {

    // Приватный конструктор: нельзя создать экземпляр этого класса
    private AppConstants() {
        throw new AssertionError("Utility class");
    }

    public static final int MAX_RETRY_ATTEMPTS = 3;
    public static final String DEFAULT_ENCODING = "UTF-8";

    // Duration вместо голого int — не перепутаете секунды с миллисекундами
    public static final Duration REQUEST_TIMEOUT = Duration.ofSeconds(30);

    // Группировка связанных констант во вложенный класс
    public static final class Database {
        private Database() {
            throw new AssertionError("Utility class");
        }

        public static final int MAX_POOL_SIZE = 100;
        public static final int MIN_IDLE_CONNECTIONS = 10;
        public static final Duration CONNECTION_TIMEOUT = Duration.ofSeconds(5);
        public static final String DEFAULT_SCHEMA = "public";
    }

    public static final class Validation {
        private Validation() {
            throw new AssertionError("Utility class");
        }

        public static final int MIN_PASSWORD_LENGTH = 12;
        public static final int MAX_PASSWORD_LENGTH = 64;
        public static final int MIN_USERNAME_LENGTH = 3;
        public static final int MAX_USERNAME_LENGTH = 50;
    }
}
```

**Почему `Duration` вместо `int`:**

```java
// Плохо: 30 — это секунды? миллисекунды?
public static final int TIMEOUT = 30;

// Хорошо: невозможно перепутать
public static final Duration TIMEOUT = Duration.ofSeconds(30);

// Использование: легко конвертировать
Thread.sleep(TIMEOUT.toMillis());
Instant deadline = Instant.now().plus(TIMEOUT);
```

> **Альтернативы классу констант:** В реальных проектах константы часто хранят не в одном классе, а в конфигурационных файлах (application.yml), перечислениях (`enum`) или типизированных конфигурационных классах. Класс `AppConstants` — простейший подход, но в крупном проекте он может разрастись до состояния «божественного класса». Выбирайте подход в зависимости от размера и структуры проекта.

### 4.4. `var`: когда использовать, а когда — нет

Золотое правило: **если, закрыв правую часть присваивания, вы всё ещё понимаете тип переменной из контекста — `var` уместен.**

**Используйте `var`:**

```java
// Тип очевиден — он написан справа
var users = new ArrayList<String>();
var config = new HashMap<String, Object>();

// Тип понятен из имени метода
var user = userService.findById(id);

// В циклах
for (var entry : map.entrySet()) {
    // ...
}
```

**Не используйте `var`:**

```java
// Непонятно, что возвращает метод
var result = process();       // String? int? List? Object?
var data = getCode();         // Нет способа понять тип, не заглядывая в метод

// Лучше: явный тип
String result = process();
List<String> data = getCode();
```

**Тонкость, о которой стоит знать:**

```java
// Без var — тип переменной: интерфейс List
List<String> items = new ArrayList<>();

// С var — тип переменной: конкретный класс ArrayList
var items = new ArrayList<String>();
```

Во втором случае вы привязываетесь к конкретной реализации. Если позже захотите заменить `ArrayList` на `LinkedList`, компилятор не позволит без изменения объявления. В большинстве случаев это неважно для локальных переменных, но знать об этом стоит.

### 4.5. Безопасное логирование

> Этот подраздел актуален, если вы используете библиотеки логирования (SLF4J, Logback, Log4j). Если вы пока используете только `System.out.println`, просто запомните главное правило: **никогда не выводите пароли, номера карт и персональные данные.**

```java
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public class OrderService {

    private static final Logger log = LoggerFactory.getLogger(OrderService.class);

    public void processOrder(String userId, String creditCardNumber) {

        // ❌ ОПАСНО: номер карты в логах — нарушение стандарта PCI DSS
        // log.info("Processing payment: card={}", creditCardNumber);

        // ❌ ОПАСНО: пароль в логах — моментальный провал security-аудита
        // log.info("Login attempt: password={}", password);

        // ✅ БЕЗОПАСНО: логируем только идентификаторы и метаданные
        log.info("Processing order: userId={}", userId);

        // ✅ БЕЗОПАСНО: маскируем чувствительные данные
        String maskedCard = "****" + creditCardNumber.substring(creditCardNumber.length() - 4);
        log.info("Payment processed: card={}", maskedCard);
    }
}
```

**Важная деталь про производительность:** аргументы метода в Java вычисляются **до** вызова метода. Это значит:

```java
// Метод expensiveOperation() будет вызван ВСЕГДА,
// даже если уровень DEBUG выключен
log.debug("Data: {}", expensiveOperation());

// Правильно: проверяем уровень перед дорогой операцией
if (log.isDebugEnabled()) {
    log.debug("Data: {}", expensiveOperation());
}
```

Плейсхолдеры `{}` экономят на **форматировании строки** (конкатенация не происходит, если уровень выключен), но **вычисление аргументов** они не предотвращают.

### 4.6. Records: неизменяемые данные (Java 16+)

> Records стали стабильной частью языка в **Java 16**. В Java 14 и 15 они были доступны только с флагом `--enable-preview`. Для production-кода используйте Java 16+.

До records для простого класса с данными требовалось написать десятки строк: поля, конструктор, геттеры, `equals`, `hashCode`, `toString`. Record делает это за вас:

```java
// Одна строка вместо пятидесяти
public record UserDto(String id, String name, int age) {}
```

Что компилятор генерирует автоматически:

- Три **private final** поля: `id`, `name`, `age`
- Конструктор: `new UserDto("123", "Alice", 30)`
- Методы доступа (без префикса `get`): `user.id()`, `user.name()`, `user.age()`
- `equals()` и `hashCode()` — сравнение по значениям всех полей
- `toString()` — строковое представление: `UserDto[id=123, name=Alice, age=30]`

**Использование:**

```java
var user1 = new UserDto("123", "Alice", 30);
var user2 = new UserDto("123", "Alice", 30);

System.out.println(user1.name());           // Alice (не getName()!)
System.out.println(user1.equals(user2));     // true — сравнение по значениям
System.out.println(user1);                   // UserDto[id=123, name=Alice, age=30]
```

**Record с валидацией (compact constructor):**

```java
public record UserDto(String id, String name, int age) {

    // Compact constructor — без круглых скобок и параметров
    public UserDto {
        if (id == null || id.isBlank()) {
            throw new IllegalArgumentException("id cannot be null or blank");
        }
        if (name == null || name.isBlank()) {
            throw new IllegalArgumentException("name cannot be null or blank");
        }
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("age must be between 0 and 150, got: " + age);
        }
        // Присваивание полям произойдёт автоматически после этого блока
    }
}
```

**Record с дополнительными методами:**

```java
public record OrderDto(String orderId, String userId, BigDecimal amount, LocalDate orderDate) {

    public OrderDto {
        Objects.requireNonNull(orderId);
        Objects.requireNonNull(userId);
        Objects.requireNonNull(amount);
        Objects.requireNonNull(orderDate);
        if (amount.compareTo(BigDecimal.ZERO) < 0) {
            throw new IllegalArgumentException("amount cannot be negative");
        }
    }

    // Можно добавлять свои методы
    public boolean isLargeOrder() {
        return amount.compareTo(new BigDecimal("1000")) > 0;
    }

    public String formattedAmount() {
        return "$" + amount.toPlainString();
    }
}
```

> Обратите внимание: для денежных сумм здесь используется `BigDecimal`, а не `double`. Почему — объясняется в разделе 5 (Грабли).

### 4.7. Многопоточность: когда нужна защита

> Этот подраздел предполагает базовое понимание потоков. Если вы пока не работали с многопоточностью, запомните главное: **если переменную читают и пишут несколько потоков одновременно, нужна защита.**

Проблема: операция `count++` выглядит как одно действие, но внутри это **три операции**: прочитать значение, прибавить единицу, записать обратно. Между этими шагами другой поток может вклиниться и испортить результат.

```java
// ❌ НЕ потокобезопасно
public class Counter {
    private int count = 0;

    public void increment() {
        count++; // Три операции, между которыми может вклиниться другой поток
    }
}
```

**Решения:**

```java
// Вариант 1: synchronized — простой, но блокирующий
public class SynchronizedCounter {
    private int count = 0;

    public synchronized void increment() {
        count++;
    }

    public synchronized int getCount() {
        return count;
    }
}

// Вариант 2: AtomicInteger — лучше для простых операций
import java.util.concurrent.atomic.AtomicInteger;

public class AtomicCounter {
    private final AtomicInteger count = new AtomicInteger(0);

    public void increment() {
        count.incrementAndGet(); // Атомарная операция — не требует блокировки
    }

    public int getCount() {
        return count.get();
    }
}
```

**Ключевое слово `volatile`:**

`volatile` решает другую проблему — **видимость** изменений. Без `volatile` один поток может не увидеть изменения, сделанные другим потоком, из-за оптимизаций процессора и компилятора.

```java
public class Task {
    // Без volatile: второй поток может никогда не увидеть, что флаг изменился
    // С volatile: изменение гарантированно видно всем потокам
    private volatile boolean stopRequested = false;

    public void requestStop() {
        stopRequested = true;
    }

    public void run() {
        while (!stopRequested) {
            // выполняем работу
        }
    }
}
```

`volatile` обеспечивает гарантии видимости и упорядочивания операций (так называемые **happens-before** отношения). Но он **не защищает** составные операции вроде `count++`. Для них нужен `synchronized` или `AtomicInteger`.

### 4.8. Тестирование


```java
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.assertThatCode;

import java.util.ArrayList;
import java.util.List;
import java.util.concurrent.atomic.AtomicInteger;

public class VariableTests {

    @Nested
    @DisplayName("Final variables")
    class FinalVariablesTests {

        @Test
        @DisplayName("Final list: нельзя переназначить ссылку, но можно изменить содержимое")
        void finalListAllowsContentModification() {
            final List<String> items = new ArrayList<>();
            items.add("first");
            items.add("second");

            assertThat(items).hasSize(2).containsExactly("first", "second");

            // items = new ArrayList<>();  — не скомпилируется
        }

        @Test
        @DisplayName("Неизменяемая коллекция бросает исключение при модификации")
        void immutableCollectionRejectsModification() {
            final List<String> items = List.of("a", "b", "c");

            assertThatThrownBy(() -> items.add("d"))
                .isInstanceOf(UnsupportedOperationException.class);
        }
    }

    @Nested
    @DisplayName("Records")
    class RecordTests {

        record UserDto(String id, String name, int age) {}

        @Test
        @DisplayName("Два record с одинаковыми значениями равны")
        void recordsWithSameValuesAreEqual() {
            var user1 = new UserDto("123", "Alice", 30);
            var user2 = new UserDto("123", "Alice", 30);

            assertThat(user1).isNotSameAs(user2);        // разные объекты
            assertThat(user1).isEqualTo(user2);           // но равны по значениям
            assertThat(user1.hashCode()).isEqualTo(user2.hashCode());
        }

        @Test
        @DisplayName("toString содержит все поля")
        void toStringContainsAllFields() {
            var user = new UserDto("123", "Alice", 30);

            assertThat(user.toString())
                .contains("123")
                .contains("Alice")
                .contains("30");
        }
    }

    @Nested
    @DisplayName("Concurrency")
    class ConcurrencyTests {

        @Test
        @DisplayName("AtomicInteger корректно работает в нескольких потоках")
        void atomicIntegerIsThreadSafe() throws InterruptedException {
            final AtomicInteger counter = new AtomicInteger(0);
            final int threadCount = 10;
            final int incrementsPerThread = 1000;

            Thread[] threads = new Thread[threadCount];
            for (int i = 0; i < threadCount; i++) {
                threads[i] = new Thread(() -> {
                    for (int j = 0; j < incrementsPerThread; j++) {
                        counter.incrementAndGet();
                    }
                });
                threads[i].start();
            }

            for (Thread thread : threads) {
                thread.join(5000); // ждём максимум 5 секунд
            }

            assertThat(counter.get()).isEqualTo(threadCount * incrementsPerThread);
        }
    }

    @Nested
    @DisplayName("Validation")
    class ValidationTests {

        record ValidatedUser(String name, int age) {
            public ValidatedUser {
                if (name == null || name.isBlank()) {
                    throw new IllegalArgumentException("name cannot be null or blank");
                }
                if (age < 0 || age > 150) {
                    throw new IllegalArgumentException("age must be between 0 and 150");
                }
            }
        }

        @Test
        @DisplayName("Валидация отклоняет некорректные данные")
        void rejectsInvalidData() {
            assertThatThrownBy(() -> new ValidatedUser(null, 30))
                .isInstanceOf(IllegalArgumentException.class);

            assertThatThrownBy(() -> new ValidatedUser("Alice", -1))
                .isInstanceOf(IllegalArgumentException.class);
        }

        @Test
        @DisplayName("Валидация пропускает корректные данные")
        void acceptsValidData() {
            assertThatCode(() -> new ValidatedUser("Alice", 30))
                .doesNotThrowAnyException();
        }
    }
}
```

---

## Раздел 5: Грабли

Этот раздел — коллекция ловушек, в которые попадают Java-разработчики. Некоторые из них приводят к ошибкам компиляции (и это хорошо — вы сразу видите проблему). Другие компилируются без проблем, но ломаются в рантайме или дают неправильные результаты.

### 5.1. `var` с `null`


```java
var x = null;  // Ошибка компиляции: компилятор не может определить тип
```

`var` выводит тип из правой части выражения. У `null` нет типа, поэтому компилятор сдаётся.

### 5.2. Shadowing: переменная прячет переменную


```java
public class User {
    private String name = "Alice";

    public void setName(String name) {
        name = name;  // Параметр присваивается самому себе! Поле не меняется.
        // Правильно: this.name = name;
    }
}
```

Параметр `name` «затеняет» поле `name`. Без `this.` вы работаете с параметром, а не с полем.

### 5.3. Использование до инициализации

```java
public void test() {
    int x;
    System.out.println(x); // Ошибка компиляции: переменная не инициализирована
}
```

Java требует, чтобы локальные переменные были инициализированы перед использованием. А вот поля объекта инициализируются автоматически: числа — нулём, boolean — `false`, ссылки — `null`.

### 5.4. `final` для ссылочных типов

Самая частая ловушка новичков:

```java
final List<String> items = new ArrayList<>();
items.add("test");        // ✅ Можно! Содержимое списка меняется.
items = new ArrayList<>(); // ❌ Ошибка компиляции. Ссылку переназначить нельзя.
```

`final` запрещает **переназначить ссылку** (показать на другой объект), но **не запрещает менять содержимое** объекта. Для настоящей неизменяемости используйте `List.of()`:

```java
final List<String> items = List.of("a", "b", "c");
items.add("d"); // UnsupportedOperationException во время выполнения
```

### 5.5. Видимость переменных в блоках

```java
try (var reader = new BufferedReader(new FileReader("file.txt"))) {
    String line = reader.readLine();
}
System.out.println(line); // Ошибка компиляции: line объявлена внутри try-блока

// Правильно:
String line;
try (var reader = new BufferedReader(new FileReader("file.txt"))) {
    line = reader.readLine();
}
System.out.println(line);
```

Переменная видна только в том блоке (между `{ }`), в котором она объявлена.

### 5.6. Pattern Matching: область видимости (Java 16+)

```java
if (obj instanceof String s) {
    System.out.println(s.length()); // ✅ s видна здесь
}
System.out.println(s.length()); // ❌ Ошибка: s не видна за пределами if

// С оператором &&: работает
if (obj instanceof String s && s.length() > 5) { // ✅ s видна после &&
    System.out.println(s);
}

// С оператором ||: не работает
if (obj instanceof String s || someCondition) {
    System.out.println(s); // ❌ Ошибка: s может быть не инициализирована
}
```

Логика простая: `s` видна только там, где компилятор может **гарантировать**, что проверка `instanceof` прошла успешно. После `&&` — может, после `||` — нет.

### 5.7. Массивы и `final`

```java
final String[] arr = {"a", "b", "c"};
arr[0] = "z";  // ✅ Можно менять элементы! final защищает только ссылку.

// Ещё хуже — ковариантность массивов:
Object[] objects = new String[3]; // Компилируется!
objects[0] = 123;                  // ArrayStoreException во время выполнения!
```

Массивы в Java ковариантны: `String[]` можно присвоить в `Object[]`. Это позволяет записать в массив строк что-то, что строкой не является. Ошибка обнаружится только при запуске. С коллекциями (`List<String>`) такой проблемы нет — они инвариантны.

### 5.8. Точность дробных чисел

```java
double result = 0.1 + 0.2;
System.out.println(result); // 0.30000000000000004  — не 0.3!
```

Числа с плавающей точкой (`double`, `float`) хранятся в двоичном формате. Некоторые десятичные дроби нельзя представить в двоичной системе точно — так же, как 1/3 нельзя точно записать в десятичной.

**Для денег всегда используйте `BigDecimal`:**

```java
BigDecimal a = new BigDecimal("0.1");
BigDecimal b = new BigDecimal("0.2");
BigDecimal result = a.add(b);
System.out.println(result); // 0.3 — правильно

// Важно: используйте конструктор со строкой, а не с double!
new BigDecimal("0.1")  // ✅ точно 0.1
new BigDecimal(0.1)    // ❌ 0.1000000000000000055511151231257827021181583404541015625
```

### 5.9. Утечки через static-переменные

```java
public class UserCache {
    // Если никогда не удалять записи — коллекция будет расти бесконечно
    private static final Map<String, User> cache = new HashMap<>();

    public static void addUser(User user) {
        cache.put(user.getId(), user);
    }
    // Метода removeUser нет — утечка памяти!
}
```

Static-переменные живут столько же, сколько загружен класс (обычно — всё время работы приложения). Если вы складываете данные в static-коллекцию и не очищаете её, память будет расти до `OutOfMemoryError`.

**Решения:**

- Используйте кэш с ограничением размера и автоматическим вытеснением (библиотеки Caffeine, Guava Cache).
- Если пишете свой кэш, добавьте политику удаления: по времени, по размеру, по LRU.

---

## Приложения

### Чеклист для code review

- [ ]  Все переменные имеют понятные имена?
- [ ]  `final` используется для переменных, которые не переназначаются?
- [ ]  Нет магических чисел (все вынесены в константы)?
- [ ]  `var` использован только там, где тип очевиден из контекста?
- [ ]  Нет shadowing переменных?
- [ ]  Переменные, доступные из нескольких потоков, защищены (`volatile`, `synchronized`, `Atomic*`)?
- [ ]  Нет неограниченно растущих static-коллекций?
- [ ]  Финансовые расчёты используют `BigDecimal`?

### Таблица примитивных типов

|Тип|Размер|Диапазон|
|---|---|---|
|`byte`|8 бит|−128 .. 127|
|`short`|16 бит|−32 768 .. 32 767|
|`int`|32 бита|−2³¹ .. 2³¹−1|
|`long`|64 бита|−2⁶³ .. 2⁶³−1|
|`float`|32 бита|≈±1.4×10⁻⁴⁵ .. ≈±3.4×10³⁸|
|`double`|64 бита|≈±4.9×10⁻³²⁴ .. ≈±1.8×10³⁰⁸|
|`char`|16 бит|0 .. 65 535 (UTF-16 code unit)¹|
|`boolean`|не специфицирован²|`true` / `false`|

¹ `char` хранит одну единицу кодировки UTF-16. Символы за пределами Basic Multilingual Plane (например, многие эмодзи) занимают **два** `char`.

² Спецификация JVM не определяет точный размер `boolean`. На практике одиночный `boolean` часто занимает 1 байт, в массивах — тоже 1 байт на элемент, но конкретное поведение зависит от реализации JVM.

### Ссылки

- [JLS §4.12 Variables](https://docs.oracle.com/javase/specs/jls/se21/html/jls-4.html#jls-4.12)
- [JEP 286: Local-Variable Type Inference (var)](https://openjdk.org/jeps/286)
- [JEP 394: Pattern Matching for instanceof](https://openjdk.org/jeps/394) — финализирован в Java 16
- [JEP 395: Records](https://openjdk.org/jeps/395) — финализированы в Java 16
- [Java Memory Model (JLS §17.4)](https://docs.oracle.com/javase/specs/jls/se21/html/jls-17.html#jls-17.4)

---

_Статья охватывает путь от базовых концепций до production-практик. Не пытайтесь усвоить всё за один раз — возвращайтесь к сложным разделам по мере роста опыта._