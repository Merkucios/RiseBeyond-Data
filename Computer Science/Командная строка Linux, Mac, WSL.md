# Командная строка: От Нуба до Профи

**Практикум для будущего Java-разработчика**

---

## ЧАСТЬ 1: НАВИГАЦИЯ И УПРАВЛЕНИЕ ФАЙЛАМИ

---

### 0. Введение: Зачем тебе чёрный экран с мигающим курсором

Ты открываешь терминал и видишь это:

text

```
user@computer:~$ █
```

Мигающий курсор. Пустота. Никаких кнопочек, менюшек, иконок. Только ты и этот молчаливый прямоугольник, который чего-то ждёт.

Первая мысль: «Зачем мне это, если есть нормальный интерфейс с мышкой?»

Ответ: потому что половина инструментов, которыми ты будешь пользоваться как Java-разработчик, существуют **только** здесь.

- **Сервер**, на который ты деплоишь приложение — не имеет графического интерфейса. Вообще. Там только терминал.
- **Git** — система контроля версий — работает через терминал.
- **Docker** — контейнеризация — терминал.
- **Maven/Gradle** — сборка Java-проектов — терминал.
- **SSH** — подключение к удалённым серверам — терминал.
- **CI/CD** — автоматические сборки и деплои — скрипты в терминале.

Ты можешь написать идеальный Java-код, но если не умеешь открыть терминал и набрать `git push` — этот код так и останется на твоём компьютере.

#### Что такое командная строка на самом деле

Командная строка — это диалог с компьютером на его языке. Ты пишешь команду — компьютер её выполняет.

Каждая команда — это глагол:

- `ls` = «покажи» (что здесь лежит)
- `cd` = «перейди» (в другую папку)
- `rm` = «удали» (этот файл)
- `cp` = «скопируй»
- `mv` = «перемести»

**Shell** (оболочка терминала) — просто переводчик между тобой и операционной системой. Ты говоришь «покажи» — он переводит на язык ОС — ОС показывает.

#### Правила безопасности на первое время

- **Всегда знай, где ты.** Прежде чем что-то удалять — набери `pwd`.
- **Используй `rm -i`** — удаление с подтверждением.
- **Не копируй слепо команды с `sudo rm -rf`** из интернета.
- **`man команда`** — встроенная документация. `man grep`, `man find`, `man chmod` — привыкай читать мануалы, а не только гуглить.

#### Формат практикума

Статья разбита на уровни:

- **Уровень 1** — Навигация (где я? что вокруг?)
- **Уровень 2** — Создание и удаление (mkdir, touch, rm)
- **Уровень 3** — Потоки и поиск (пайпы, grep, find)
- **Уровень 4** — Скриптинг (пишем настоящий bash-скрипт)
- **Босс-файт** — Пишем скрипт бэкапа, который реально полезен
- **Уровень 5** — Продвинутые инструменты (процессы, сеть, SSH)

**Не читай пассивно — открой терминал и делай.**

---

### Быстрая настройка окружения (5 минут)

#### Mac

Нажми `Cmd + Пробел`, набери «Terminal», нажми Enter.

> **Важно:** С macOS Catalina (2019) оболочка по умолчанию — **zsh**, а не bash. Для этого практикума разницы почти нет — все базовые команды работают одинаково. Но если ты пишешь скрипты — знай, что `/bin/bash` на Mac — это **Bash 3.2 (2007 года!)**, замороженный из-за лицензии. Для актуальной версии: `brew install bash`.

Проверка:

Bash

```
echo "Hello"
```

Видишь `Hello` — переходи к Уровню 1.

#### Linux

В большинстве окружений рабочего стола (GNOME, Ubuntu) — нажми `Ctrl + Alt + T`. Если не сработало — найди «Terminal» в меню приложений (шорткат зависит от твоего DE: KDE, i3 и другие используют свои).

Bash

```
echo "Hello"
```

#### Windows → WSL2

На Windows нужен дополнительный шаг.

**Почему WSL2, а не Git Bash:**

Git Bash работает нормально для базовых задач и Git. Но WSL2 — это **настоящий Linux** внутри Windows: настоящее ядро, полная совместимость. Для серьёзной работы с Docker, серверными утилитами и скриптами — WSL2 надёжнее.

**Рекомендация:** Также установи **[Windows Terminal](https://aka.ms/terminal)** — современный терминал с табами, темами и нормальным рендерингом. И помни, что **VS Code** имеет встроенный терминал (`Ctrl + ```) с поддержкой WSL.

**Установка WSL2 (пошагово):**

1. Убедись, что Windows обновлена (Windows 10 версия 2004+ или Windows 11)
2. Открой **PowerShell от имени администратора**
3. Введи:

PowerShell

```
wsl --install
```

4. Перезагрузи компьютер
5. После перезагрузки откроется окно Ubuntu — создай имя пользователя и пароль
6. Проверь:

Bash

```
wsl --status
```

7. Обнови пакеты:

Bash

```
sudo apt update && sudo apt upgrade -y
```

> **Что здесь происходит:** `sudo` — это команда, которая выполняет следующую за ней команду **с правами администратора** (root). Система спросит твой пароль. `apt` — менеджер пакетов Ubuntu. `update` — обновить список доступных пакетов, `upgrade` — установить обновления. Флаг `-y` — автоматически отвечать «да» на вопросы. Подробнее о `sudo` — в разделе Troubleshooting.

Проверка:

Bash

```
echo "Hello"
```

---

## УРОВЕНЬ 1: Навигация — «Где я и что вокруг»

### 1.1. Ментальная модель: файловая система — это дерево

Файловая система — это **дерево** (перевёрнутое, корнем вверх на схемах — но корень всё равно корень).

text

```
/                          ← Корень (root). Начало всего.
├── home/                  ← Домашние директории пользователей
│   ├── alice/             ← Домашняя директория Алисы
│   │   ├── Documents/
│   │   ├── Downloads/
│   │   └── projects/
│   │       ├── java-zero/
│   │       │   ├── src/
│   │       │   │   └── Main.java
│   │       │   └── README.md
│   │       └── blog/
│   │           └── index.html
│   └── bob/               ← Домашняя директория Боба
├── etc/                   ← Конфигурации системы
├── tmp/                   ← Временные файлы
├── usr/                   ← Программы и библиотеки
│   ├── bin/               ← Здесь живут команды (ls, cp, grep...)
│   └── lib/               ← Библиотеки
├── var/                   ← Логи и переменные данные
│   └── log/
└── bin/                   ← Базовые команды
```

> **Совет:** установи `tree` (`sudo apt install tree` или `brew install tree`) — она покажет структуру директории в виде красивого дерева, как на схеме выше. Гораздо нагляднее, чем `ls -R`:
> 
> Bash
> 
> ```
> tree myproject
> # myproject
> # ├── README.md
> # ├── src
> # │   └── Main.java
> # └── tests
> #     └── MainTest.java
> ```

**Ключевой момент:** ты всегда находишься в одной конкретной директории. Когда открываешь терминал — обычно оказываешься в своей домашней (`/home/alice`).

**Самый важный вопрос:** «Где я сейчас?»

### 1.2. Команда `pwd` — «Где я?»

`pwd` = **P**rint **W**orking **D**irectory.

Bash

```
user@computer:~$ pwd
/home/user
```

**Правило:** потерялся — начни с `pwd`. Всегда.

### 1.3. Полезные команды «кто я?»

Bash

```
whoami     # имя текущего пользователя
# user

id         # подробная информация: UID, группы
# uid=1000(user) gid=1000(user) groups=1000(user),27(sudo)
```

Понимание «от кого я работаю» напрямую связано с правами доступа. Если `whoami` говорит `root` — будь особенно осторожен.

### 1.4. Команда `ls` — «Что здесь лежит?»

`ls` = **L**i**s**t.

Bash

```
user@computer:~$ ls
Desktop  Documents  Downloads  projects
```

**Флаги:**

`ls -l` — подробный формат:

Bash

```
user@computer:~$ ls -l
total 16
drwxr-xr-x 2 user user 4096 Jun 23 10:00 Desktop
drwxr-xr-x 2 user user 4096 Jun 23 10:00 Documents
drwxr-xr-x 2 user user 4096 Jun 23 10:00 Downloads
drwxr-xr-x 3 user user 4096 Jun 23 10:00 projects
```

`ls -a` — показать всё, включая скрытые файлы:

Bash

```
user@computer:~$ ls -a
.  ..  .bashrc  .profile  Desktop  Documents  Downloads  projects
```

Файлы, начинающиеся с точки — скрытые (настройки: `.bashrc`, `.profile`). Обрати внимание на `.` и `..` — о них дальше.

`ls -la` — комбо (подробно + скрытые). **Твой рабочий инструмент на каждый день:**

Bash

```
user@computer:~$ ls -la
total 32
drwxr-xr-x 6 user user 4096 Jun 23 10:00 .
drwxr-xr-x 3 root root 4096 Jun 23 09:00 ..
-rw-r--r-- 1 user user  220 Jun 23 09:00 .bashrc
-rw-r--r-- 1 user user  807 Jun 23 09:00 .profile
drwxr-xr-x 2 user user 4096 Jun 23 10:00 Desktop
drwxr-xr-x 2 user user 4096 Jun 23 10:00 Documents
drwxr-xr-x 2 user user 4096 Jun 23 10:00 Downloads
drwxr-xr-x 3 user user 4096 Jun 23 10:00 projects
```

### 1.5. Концепция `.` и `..`

- `.` (одна точка) = **текущая директория**. «Здесь.»
- `..` (две точки) = **родительская директория**. «Уровень выше.»

Это реальные записи в каждой директории. Ты будешь использовать их постоянно.

Если ты в `/home/user/projects`:

text

```
.  = /home/user/projects     (здесь)
.. = /home/user               (уровень выше)
```

### 1.6. Команда `cd` — «Перейти»

`cd` = **C**hange **D**irectory.

Bash

```
# Зайти в подпапку
cd projects
pwd
# /home/user/projects

# Зайти глубже
cd java-zero
pwd
# /home/user/projects/java-zero

# Подняться на уровень выше
cd ..
pwd
# /home/user/projects

# Ещё выше
cd ..
pwd
# /home/user

# Вернуться домой (из любого места)
cd ~
pwd
# /home/user

# Перейти в корень
cd /
ls
# bin  boot  dev  etc  home  lib  ...

# Вернуться в предыдущую директорию (как "Назад" в браузере)
cd -
```

### 1.7. Абсолютный vs Относительный путь

Это источник **80% ошибок новичков**. Пойми один раз — дальше всё встанет на свои места.

**Абсолютный путь** — от корня `/`. Полный, однозначный адрес:

text

```
/home/user/projects/java-zero/src/Main.java
```

Признак: **начинается с `/`**. Работает из любой точки.

**Относительный путь** — от текущей позиции:

text

```
projects/java-zero/src/Main.java
```

Признак: **начинается с имени, `./` или `../`**. Работает только если ты в правильной директории.

**Пример.** Ты в `/home/user/projects`:

|Цель|Абсолютный путь|Относительный путь|
|---|---|---|
|Main.java|`/home/user/projects/java-zero/src/Main.java`|`java-zero/src/Main.java`|
|README.md|`/home/user/projects/java-zero/README.md`|`java-zero/README.md`|
|notes.txt|`/home/user/Documents/notes.txt`|`../Documents/notes.txt`|

В последнем примере: `..` — поднимаемся в `/home/user`, оттуда в `Documents`.

**Когда что:**

- **В скриптах** — предпочитай абсолютные пути. Они работают одинаково, откуда бы скрипт ни запустили.
- **В повседневной работе** — относительные короче и удобнее.

### 1.8. Символические ссылки (симлинки)

Иногда при навигации ты наткнёшься на символические ссылки — это «ярлыки» в Linux:

Bash

```
ls -l /usr/bin/java
# lrwxrwxrwx 1 root root 22 Jun 23 ... /usr/bin/java -> /etc/alternatives/java
```

Видишь `->` ? Это симлинк. `/usr/bin/java` — не настоящий файл, а указатель на другой файл.

Создание:

Bash

```
ln -s /путь/к/оригиналу /путь/к/ссылке

# Пример: создать короткую ссылку на глубоко вложенный проект
ln -s /home/user/projects/java-zero/src ~/javasrc
cd ~/javasrc    # теперь это работает!
```

Симлинки используются повсюду: `java`, `python`, `node` — почти всегда это симлинки. Система `alternatives` в Linux — целиком на них построена.

### 1.9. Бонусные команды навигации

**`history`** — что я вводил раньше:

Bash

```
history
```

**`clear`** (или `Ctrl + L`) — очистить экран.

**`Tab`** — **автодополнение. Самая важная клавиша в терминале.**

Bash

```
cd pro<Tab>
# Автоматически дополнится до:
cd projects/
```

Если есть несколько вариантов — нажми `Tab` дважды, терминал покажет все.

**Стрелка вверх `↑`** — листать историю команд.

**`man команда`** — встроенная документация:

Bash

```
man ls       # документация по ls
man grep     # документация по grep
# Навигация: стрелки, /слово — поиск, q — выход
```

### 1.10. Мини-задание «Разведчик»

text

```
Задание:
─────────────────────────────────────────────────
1. Узнай, где ты:              pwd
2. Узнай, кто ты:              whoami
3. Осмотрись (со скрытыми):    ls -la
4. Перейди в корень:           cd /
5. Осмотрись:                  ls
6. Вернись домой:              cd ~
7. Перейди в /tmp:             cd /tmp
8. Вернись назад:              cd -
9. Выведи историю:             history
10. Открой мануал по ls:       man ls  (выход: q)
11. Посмотри структуру домашней директории:
    tree -L 2 ~     (если установлен tree)

Цель: ни разу не заблудиться.
Заблудился — pwd тебе в помощь.
─────────────────────────────────────────────────
```

---

## УРОВЕНЬ 2: Демиург — «Создаю и Уничтожаю»

### 2.1. Создание

#### `mkdir` — создать директорию

Bash

```
mkdir myproject
```

Вложенная структура — флаг `-p` (parents):

Bash

```
# Без -p — ошибка, если промежуточных папок нет:
mkdir myproject/src/main/java
# mkdir: cannot create directory: No such file or directory

# С -p — создаёт всю цепочку:
mkdir -p myproject/src/main/java
```

#### `touch` — создать пустой файл

Bash

```
touch README.md

# Несколько файлов:
touch app.java config.txt notes.md
```

Если файл уже существует, `touch` **не стирает** содержимое — только обновляет дату модификации.

#### `cp` — копировать

Bash

```
# Файл
cp file.txt copy.txt

# Директория (нужен -r — рекурсивно)
cp -r myproject myproject-backup

# С сохранением метаданных (права, время, владелец) — используй -a
cp -a myproject myproject-backup
```

#### `mv` — переместить или переименовать

Bash

```
# Переименование
mv old-name.txt new-name.txt

# Перемещение (если второй аргумент — существующая директория)
mv file.txt ../
mv file.txt /home/user/Documents/

# Если путь назначения — в несуществующей директории:
mv file.txt /nonexistent/path/name.txt
# Ошибка! Промежуточные папки не создаются автоматически.
```

### 2.2. Просмотр содержимого

**`cat`** — вывести содержимое файла (для коротких файлов):

Bash

```
cat README.md
```

**`less`** — **просмотр с навигацией (для больших файлов)**:

Bash

```
less server.log
```

Навигация в `less`:

|Клавиша|Действие|
|---|---|
|`↑` / `↓`|Прокрутка|
|`Пробел`|Страница вниз|
|`b`|Страница вверх|
|`/слово`|Поиск вперёд|
|`?слово`|Поиск назад|
|`n`|Следующее совпадение|
|`q`|Выход|

> **Правило:** файл меньше экрана — `cat`. Файл больше экрана — `less`. Тот лог в 500 МБ из примера с `grep`? Только `less`. Вывод длинной команды? Прогони через пайп: `grep "ERROR" server.log | less`.

**`nano`** — простой редактор в терминале:

Bash

```
nano README.md
# Ctrl+O — сохранить, Ctrl+X — выйти
```

### 2.3. Уничтожение

> ⚠️ **КРАСНАЯ ЗОНА.** Читай внимательно.

#### `rm` — удалить файл

Bash

```
rm file.txt
```

**В Linux НЕТ корзины.** `rm` удаляет файл **необратимо**.

**Безопасная альтернатива — `rm -i`:**

Bash

```
rm -i file.txt
# rm: remove regular file 'file.txt'? y
```

#### `rm -r` — удалить директорию (рекурсивно)

Bash

```
rm -r mydir      # с подтверждениями (если много файлов)
rm -rf mydir     # force — молча и быстро (опасно!)
```

**Правило перед любым `rm`:**

1. `pwd` — убедись, что ты в правильной директории
2. `ls` — посмотри, что собираешься удалить

### 2.4. Сравнение файлов — `diff`

Частая задача: «Что изменилось между двумя версиями?»

Bash

```
diff config.txt config.txt.bak
# 3c3
# < port=8080
# ---
# > port=3000

# Более читаемый формат (unified):
diff -u old_version.txt new_version.txt
# --- old_version.txt
# +++ new_version.txt
# @@ -1,3 +1,3 @@
#  server=localhost
# -port=3000
# +port=8080
#  debug=false
```

`-` = строка удалена, `+` = строка добавлена. Этот формат ты будешь видеть постоянно в `git diff`.

### 2.5. Практическое задание

Bash

```
# 1. Убедимся, что мы дома
pwd

# 2. Создадим папку
mkdir java-zero

# 3. Зайдём
cd java-zero

# 4. Создадим файл
touch Hello.txt

# 5. Запишем текст
echo "Привет, мир!" > Hello.txt

# 6. Проверим
cat Hello.txt
# Привет, мир!
```

### 2.6. Мини-задание «Архитектор»

text

```
Задание:
─────────────────────────────────────────────────
1. Создай структуру проекта одной командой:
   mkdir -p myapp/src myapp/tests myapp/docs

2. Создай файлы:
   touch myapp/src/Main.java
   touch myapp/tests/MainTest.java
   touch myapp/README.md

3. Проверь структуру:
   tree myapp      (или ls -R myapp)

4. Переименуй docs в documentation:
   mv myapp/docs myapp/documentation

5. Скопируй README.md в documentation:
   cp myapp/README.md myapp/documentation/

6. Сравни копию с оригиналом:
   diff myapp/README.md myapp/documentation/README.md

7. Удали папку tests (с подтверждением):
   rm -ri myapp/tests

8. Проверь результат:
   tree myapp
─────────────────────────────────────────────────
```

---

## ЧАСТЬ 2: ПОТОКИ И ПОИСК

---

## УРОВЕНЬ 3: Магия потоков — «Пайпы и Перенаправление»

### 3.1. Ключевая идея: Всё есть поток текста

Каждая программа работает с тремя потоками:

text

```
                  ┌─────────────┐
    stdin ───────►│   Команда   │───────► stdout
  (вход, fd 0)   │             │         (выход, fd 1)
                  └──────┬──────┘
                         │
                         ▼
                      stderr
                    (ошибки, fd 2)
```

- **stdin** (fd 0) — входной поток (откуда получает данные)
- **stdout** (fd 1) — выходной поток (куда отправляет результат)
- **stderr** (fd 2) — поток ошибок (сообщения об ошибках)

`fd` — file descriptor (номер потока). Эти номера понадобятся через минуту.

**Ключевая идея:** можно взять stdout одной команды и направить в stdin другой. Это **пайп**.

### 3.2. Pipe `|` — «труба» между командами

text

```
Команда1 | Команда2
```

«Возьми то, что выдала Команда1, и передай на вход Команде2.»

text

```
┌──────────┐       ┌──────────┐
│  find .  │──────►│  grep    │──────► Экран
│ -name    │ pipe  │ "Test"   │
│ "*.java" │       │          │
└──────────┘   |   └──────────┘
```

Bash

```
# Найти все Java-файлы с "Test" в имени
find . -name "*.java" | grep "Test"

# Найти все cd в истории
history | grep "cd"

# Пайпы можно цепочкой:
find . -name "*.java" | sort | head -10
```

> **Антипаттерн:** `ls -la | grep ".java"` — плохая практика. Во-первых, точка без экранирования матчит любой символ (`.java` заматчит и `xjava`). Во-вторых, парсить вывод `ls` ненадёжно (пробелы в именах ломают всё). **Правильно:** `find . -name "*.java"`.

Это **философия Unix**: маленькие программы, каждая делает одно дело хорошо, и ты комбинируешь их пайпами.

### 3.3. `grep` — поиск текста

`grep` = **G**lobal **R**egular **E**xpression **P**rint.

Суть простая: **grep ищет текст**.

#### Реальный кейс: найти ошибку в огромном лог-файле

Файл `server.log` — 500 МБ, тысячи строк. Нужны ошибки.

Bash

```
grep "ERROR" server.log
```

Результат — только нужные строки:

text

```
2025-06-23 10:15:32 ERROR: Database connection failed
2025-06-23 10:15:33 ERROR: Retry attempt 1 failed
2025-06-23 10:16:01 ERROR: Service unavailable
```

Из 500 000 строк — три. Если результатов много — прогони через `less`:

Bash

```
grep "ERROR" server.log | less
```

> **Обрати внимание:** `grep` умеет читать файлы напрямую. Писать `cat file | grep "text"` — антипаттерн ([Useless Use of Cat](http://porkmail.org/era/unix/award)). Правильно: `grep "text" file`.

#### Полезные флаги:

Bash

```
# Без учёта регистра
grep -i "error" server.log

# Рекурсивно по всем файлам в директории
grep -r "TODO" .

# Подсчитать количество совпадений
grep -c "ERROR" server.log

# Показать номера строк
grep -n "ERROR" server.log

# Фиксированная строка (не регулярное выражение)
grep -F "точный.текст" file.txt
```

`grep -r "TODO" .` — ты будешь использовать это постоянно в Java-проектах.

### 3.4. `cat`, `head`, `tail`, `less` — просмотр файлов

**`cat`** — весь файл (для маленьких файлов):

Bash

```
cat config.txt
```

**`less`** — для больших файлов (с навигацией, см. раздел 2.2).

**`head`** — начало файла:

Bash

```
head server.log        # первые 10 строк
head -20 server.log    # первые 20
```

**`tail`** — конец файла:

Bash

```
tail server.log        # последние 10 строк
tail -20 server.log    # последние 20
```

**Убийственная фича — `tail -f`** (follow):

Bash

```
tail -f server.log
```

Показывает конец файла и **ждёт новых строк в реальном времени**. Мониторинг логов работающего приложения. `Ctrl + C` для выхода.

### 3.5. `sort`, `uniq` — сортировка и уникальные значения

**`sort`** — сортировка строк:

Bash

```
sort names.txt              # алфавитная сортировка
sort -n numbers.txt         # числовая сортировка
sort -r names.txt           # обратный порядок
```

**`uniq`** — убрать дубликаты (работает **только на отсортированных данных**):

Bash

```
sort names.txt | uniq       # убрать дубликаты
sort names.txt | uniq -c    # посчитать повторения
```

**Классический паттерн для анализа логов** — «Какие ошибки встречаются чаще всего?»:

Bash

```
grep "ERROR" server.log | sort | uniq -c | sort -rn | head -10
```

Расшифровка: взять ошибки → отсортировать → подсчитать одинаковые → отсортировать по частоте → показать топ-10.

### 3.6. `wc` — подсчёт

`wc` = **W**ord **C**ount.

Bash

```
wc -l file.txt    # количество строк (lines)
wc -w file.txt    # количество слов (words)
wc -m file.txt    # количество символов (characters)
wc -c file.txt    # количество байт (bytes)
```

> **Нюанс:** `-c` считает **байты**, а `-m` — **символы**. В UTF-8 кириллический символ = 2 байта. Если работаешь с русским текстом — разница принципиальна.

Часто используется с пайпами:

Bash

```
# Сколько Java-файлов в проекте?
find . -name "*.java" | wc -l

# Сколько строк с ERROR?
grep -c "ERROR" server.log
```

### 3.7. `find` — поиск файлов

`grep` ищет текст **внутри** файлов. `find` ищет **сами файлы**.

Bash

```
# Найти Main.java во всех вложенных папках
find . -name "Main.java"
# ./src/main/java/com/myapp/Main.java

# Все .java файлы
find . -name "*.java"

# Все директории с именем "test"
find . -type d -name "test"

# Файлы больше 10 МБ
find . -size +10M

# Файлы, изменённые за последние 7 дней
find . -mtime -7
```

### 3.8. `xargs` — передать результаты как аргументы

`find` находит файлы, но что если нужно **сделать что-то** с каждым найденным? `xargs` берёт строки из stdin и передаёт их как аргументы другой команде:

Bash

```
# Удалить все .class файлы
find . -name "*.class" | xargs rm

# Найти TODO во всех Java-файлах
find . -name "*.java" | xargs grep "TODO"

# Безопасная версия (корректно обрабатывает пробелы в именах)
find . -name "*.java" -print0 | xargs -0 grep "TODO"
```

Без `xargs` пришлось бы использовать `find ... -exec`, который менее удобен для цепочек.

### 3.9. `which` — где находится программа

Bash

```
which java
# /usr/bin/java

which grep
# /usr/bin/grep
```

Когда ты набираешь `java`, система ищет программу в директориях из переменной `PATH`:

Bash

```
echo $PATH
# /usr/local/bin:/usr/bin:/bin:/usr/local/sbin
```

Если программа не в `PATH` — получишь `command not found` (см. раздел **Troubleshooting**).

### 3.10. Перенаправление вывода: `>`, `>>` и stderr

#### Основы: stdout в файл

**`>`** — записать в файл (**перезапись** — старое стирается):

Bash

```
ls -la > listing.txt
```

**`>>`** — дописать в конец (**добавление** — старое сохраняется):

Bash

```
echo "Первая строка" > log.txt
echo "Вторая строка" >> log.txt
echo "Третья строка" >> log.txt
cat log.txt
# Первая строка
# Вторая строка
# Третья строка
```

**Мнемоника:** `>` = «затереть», `>>` = «добавить».

> ⚠️ Будь осторожен с `>` — можно случайно стереть важный файл!

#### Перенаправление stderr — ОБЯЗАТЕЛЬНО ЗНАТЬ

Помнишь диаграмму с тремя потоками? `>` перенаправляет только **stdout**. Ошибки (stderr) по-прежнему летят на экран. Это часто путает новичков:

Bash

```
find / -name "config.txt" > results.txt
# На экране полно "Permission denied" — это stderr
# В файле — только найденные файлы (stdout)
```

Чтобы управлять stderr, используем номер потока (`2`):

Bash

```
# Перенаправить stderr в файл
find / -name "config.txt" 2> errors.txt

# Подавить ошибки (отправить в "чёрную дыру")
find / -name "config.txt" 2>/dev/null

# Объединить stdout и stderr в один файл
java -jar app.jar > output.log 2>&1

# То же самое, короткая запись (bash 4+)
java -jar app.jar &> output.log
```

**Расшифровка `2>&1`:** «отправь поток 2 (stderr) туда же, куда идёт поток 1 (stdout)».

**Реальный кейс для Java-разработчика:**

Bash

```
# Запустить приложение, ВСЕ логи (и stdout, и stderr) в файл
java -jar myapp.jar > app.log 2>&1

# Запустить тесты, видеть вывод на экране И сохранить в файл
mvn test 2>&1 | tee test_results.log
```

### 3.11. `tee` — одновременно на экран и в файл

Иногда нужно **и видеть** вывод, **и сохранить** его:

Bash

```
# Без tee — выбирай: или экран, или файл
./build.sh > build.log       # в файл, экран пуст
./build.sh                    # на экран, файл пуст

# С tee — и то, и другое
./build.sh 2>&1 | tee build.log

# Дописать, а не перезаписать:
./build.sh 2>&1 | tee -a build.log
```

### 3.12. Комбо-примеры

Bash

```
# Найти все Java-файлы и посчитать
find . -name "*.java" | wc -l

# 5 самых больших файлов
ls -lS | head -5

# Найти процесс Java
ps aux | grep java

# Все TODO в проекте с номерами строк
grep -rn "TODO" .

# Последние 20 ошибок из лога
grep "ERROR" server.log | tail -20

# Сохранить список процессов в файл
ps aux > processes.txt

# Запустить Java-приложение, все логи в файл
java -jar app.jar > /var/log/myapp.log 2>&1

# Топ-5 самых частых ошибок
grep "ERROR" server.log | sort | uniq -c | sort -rn | head -5
```

### 3.13. Мини-задание «Детектив»

text

```
Задание:
─────────────────────────────────────────────────
1. Создай файл notes.txt с 5 строками:
   echo "Java - мой первый язык" > notes.txt
   echo "Терминал - это мощный инструмент" >> notes.txt
   echo "grep ищет текст в файлах" >> notes.txt
   echo "Пайпы соединяют команды" >> notes.txt
   echo "Java работает на JVM" >> notes.txt

2. Покажи содержимое:       cat notes.txt
3. Посчитай строки:         wc -l notes.txt
4. Найди строки с "Java":   grep "Java" notes.txt
5. Найди все .txt файлы:    find ~ -name "*.txt" 2>/dev/null
6. Сохрани результат:       find ~ -name "*.txt" 2>/dev/null > found.txt
7. Посчитай найденные:      wc -l found.txt
8. Отсортируй и покажи:     sort found.txt | less
─────────────────────────────────────────────────
```

---

## ЧАСТЬ 3: BASH-СКРИПТИНГ

---

## УРОВЕНЬ 4: Скриптинг

### 4.1. Что такое скрипт

Скрипт — текстовый файл с командами. Shell читает его строка за строкой и выполняет.

Первая строка — **shebang:**

Bash

```
#!/usr/bin/env bash
```

Разбор:

- `#!` — магическая последовательность: «это скрипт»
- `/usr/bin/env bash` — найти `bash` через `env` и использовать его как интерпретатор

> **Почему `#!/usr/bin/env bash`, а не `#!/bin/bash`?** Путь `/bin/bash` может не существовать на некоторых системах (NixOS, контейнеры). `env bash` ищет bash через `PATH` — это более переносимо и является стандартной практикой.

### 4.2. Exit codes — язык успеха и ошибок

Прежде чем писать скрипты — пойми фундаментальную концепцию.

**Каждая команда в Linux завершается с кодом возврата (exit code):**

- **0** = успех
- **не 0** = ошибка (1, 2, 127, ... — разные виды ошибок)

Bash

```
ls /home
echo $?
# 0 — успех

ls /несуществующая_папка
echo $?
# 2 — ошибка

grep "несуществующее" file.txt
echo $?
# 1 — не найдено
```

**Почему это важно:**

- `set -e` в скриптах останавливает выполнение при первом ненулевом коде — именно благодаря exit codes
- `if` в bash проверяет **exit code**, а не текстовый вывод
- CI/CD системы смотрят на exit code, чтобы понять — сборка прошла или упала
- Пайпы: `set -o pipefail` проверяет exit codes всех команд в цепочке

Bash

```
# if проверяет exit code команды, а не текст
if grep -q "ERROR" server.log; then
    echo "Ошибки найдены!"
fi

# Свой exit code при выходе из скрипта
exit 0    # всё хорошо
exit 1    # что-то пошло не так
```

### 4.3. Создание и запуск первого скрипта

**Шаг 1 — создать файл:**

Bash

```
touch hello.sh
```

**Шаг 2 — написать код:**

Bash

```
nano hello.sh
```

Bash

```
#!/usr/bin/env bash
echo "Hello, DevOps world!"
echo "Текущая дата: $(date)"
echo "Ты находишься в: $(pwd)"
```

**Шаг 3 — сделать исполняемым и запустить:**

Bash

```
./hello.sh
# bash: ./hello.sh: Permission denied
```

Ошибка! Нет права на исполнение.

#### Права доступа и `chmod`

Каждый файл имеет три набора прав:

text

```
-rw-r--r--

 │├─┤├─┤├─┤
 │ │  │  └── others (все остальные): r-- (чтение)
 │ │  └───── group (группа): r-- (чтение)
 │ └──────── owner (владелец): rw- (чтение + запись)
 └────────── тип (- = файл, d = директория)
```

Три типа прав: **r** (read) = 4, **w** (write) = 2, **x** (execute) = 1.

#### Символьная нотация:

Bash

```
chmod +x hello.sh      # добавить право исполнения всем
chmod u+x hello.sh     # добавить право исполнения только владельцу
```

#### Числовая нотация (встречается чаще в реальной работе):

Каждый набор прав — сумма: r(4) + w(2) + x(1).

Bash

```
chmod 755 hello.sh     # rwxr-xr-x (владелец: всё, остальные: чтение+исполнение)
chmod 644 config.txt   # rw-r--r-- (владелец: чтение+запись, остальные: чтение)
chmod 600 ~/.ssh/id_rsa # rw------- (только владелец читает и пишет)
chmod 700 script.sh    # rwx------ (только владелец: всё)
```

**Частые значения:**

|Число|Права|Где используется|
|---|---|---|
|`755`|`rwxr-xr-x`|Скрипты, исполняемые файлы|
|`644`|`rw-r--r--`|Обычные файлы, конфиги|
|`600`|`rw-------`|SSH-ключи (**обязательно!** SSH откажет при других правах)|
|`700`|`rwx------`|Приватные директории, скрипты|

Bash

```
ls -l hello.sh
# -rwxr-xr-x 1 user user 89 Jun 23 12:00 hello.sh

./hello.sh
# Hello, DevOps world!
# Текущая дата: Mon Jun 23 12:00:00 UTC 2025
# Ты находишься в: /home/user
```

**Почему `./`?** Точка-слеш = «файл в текущей директории». Без `./` система ищет в `PATH` (и не найдёт).

#### `chown` — смена владельца

При работе с Docker, деплое на серверах — часто нужно сменить владельца:

Bash

```
chown user:group file.txt
chown -R user:group directory/    # рекурсивно

# Пример: Docker создал файлы от root, нужно вернуть себе
sudo chown -R $(whoami):$(whoami) ./app-data/
```

> **Нюанс:** для директорий `x` означает не «запустить», а «разрешить заходить внутрь» (`cd`). И `root` (суперпользователь) игнорирует все ограничения прав.

### 4.4. Переменные

Bash

```
#!/usr/bin/env bash

name="World"
echo "Hello, $name!"

current_dir=$(pwd)
echo "Текущая директория: $current_dir"

file_count=$(find . -maxdepth 1 -type f | wc -l)
echo "Файлов в директории: $file_count"
```

**Правила:**

- Без пробелов вокруг `=`: `name="value"` ✅ — `name = "value"` ❌
- Использование: `$name` или `${name}`
- `$(команда)` — выполнить команду и подставить результат

> **Конвенция именования:** UPPERCASE (`MY_VAR`) — для переменных окружения и экспортируемых переменных. Для локальных переменных скрипта используй **lowercase** (`my_var`), чтобы не конфликтовать с системными переменными вроде `PATH`, `HOME`, `USER`.

**Специальные переменные:**

Bash

```
#!/usr/bin/env bash

echo "Имя скрипта: $0"
echo "Первый аргумент: $1"
echo "Второй аргумент: $2"
echo "Все аргументы: $@"
echo "Количество аргументов: $#"
echo "Код возврата предыдущей команды: $?"
```

Bash

```
./script.sh Alice Bob
# Имя скрипта: ./script.sh
# Первый аргумент: Alice
# Второй аргумент: Bob
# Все аргументы: Alice Bob
# Количество аргументов: 2
```

**Переменные окружения:**

Bash

```
export MY_VAR="value"
```

`export` делает переменную видимой для всех программ, которые запускает скрипт.

### 4.5. Условия (`if`)

Bash

```
#!/usr/bin/env bash

if [ -f "config.txt" ]; then
    echo "Конфигурация найдена"
else
    echo "Конфигурация не найдена, создаю..."
    touch config.txt
fi
```

> ⚠️ **Пробелы внутри `[ ]` обязательны!** `[ -f file.txt ]` ✅ — `[-f file.txt]` ❌

**Полезные проверки:**

Bash

```
[ -f file.txt ]      # файл существует?
[ -d mydir ]         # директория существует?
[ -z "$var" ]        # переменная пустая?
[ "$var" = "value" ] # строки равны?
[ ! -d mydir ]       # директория НЕ существует?
```

#### `[[ ]]` vs `[ ]` — безопаснее в bash

В bash лучше использовать двойные скобки `[[ ]]`:

Bash

```
# [ ] — старый стиль, POSIX-совместимый
# Ломается, если переменная пустая и без кавычек:
[ $var = "test" ]    # если var пустая — синтаксическая ошибка

# [[ ]] — bash-стиль, безопаснее
[[ $var = "test" ]]  # работает корректно даже без кавычек
[[ $var =~ ^[0-9]+$ ]]  # поддерживает регулярные выражения
[[ -f file.txt && -r file.txt ]]  # поддерживает && и ||
```

**Правило:** в bash-скриптах используй `[[ ]]`. `[ ]` оставь для POSIX-совместимых скриптов (#!/bin/sh).

### 4.6. Циклы

#### `for` — перебор списка

Bash

```
#!/usr/bin/env bash

for file in *.txt; do
    echo "Обрабатываю: $file"
done
```

Bash

```
#!/usr/bin/env bash

for name in Alice Bob Charlie; do
    echo "Привет, $name!"
done
```

#### `while` и `read` — чтение файла построчно

Bash

```
#!/usr/bin/env bash

# Обработать каждую строку файла
while IFS= read -r line; do
    echo "Строка: $line"
done < file.txt
```

Bash

```
#!/usr/bin/env bash

# Обработать вывод команды построчно
find . -name "*.java" | while IFS= read -r file; do
    echo "Java-файл: $file"
    wc -l "$file"
done
```

### 4.7. Функции

Когда скрипт растёт — разбивай на функции:

Bash

```
#!/usr/bin/env bash
set -euo pipefail

# Определение функции
log_info() {
    echo "[INFO] $(date +%H:%M:%S) $1"
}

log_error() {
    echo "[ERROR] $(date +%H:%M:%S) $1" >&2
}

check_directory() {
    local dir="$1"    # local — переменная видна только внутри функции
    if [[ ! -d "$dir" ]]; then
        log_error "Директория '$dir' не найдена"
        return 1      # return — exit code функции
    fi
    log_info "Директория '$dir' — OK"
    return 0
}

# Использование
check_directory "/home/user/projects"
check_directory "/несуществующая"
```

**Ключевое:** `local` — переменная не «утечёт» за пределы функции. Без `local` переменная будет глобальной.

### 4.8. Heredoc — многострочные строки

Когда нужно создать файл с несколькими строками или сгенерировать конфиг:

Bash

```
cat <<EOF > config.yml
server:
  port: 8080
  host: localhost
database:
  url: jdbc:postgresql://localhost:5432/mydb
EOF
```

`<<EOF` ... `EOF` — всё между маркерами подставляется как текст. Переменные внутри раскрываются:

Bash

```
port=8080
cat <<EOF > config.yml
server:
  port: $port
EOF
# В файле будет port: 8080
```

Если нужно **без** подстановки переменных — закавычь маркер:

Bash

```
cat <<'EOF' > script_template.sh
echo "Значение переменной: $1"
EOF
# В файле будет буквально $1, а не подставленное значение
```

### 4.9. `set -euo pipefail` — страховка для скриптов

Добавляй **сразу после shebang** в каждый скрипт:

Bash

```
#!/usr/bin/env bash
set -euo pipefail
```

Что это даёт:

- **`-e`** — скрипт останавливается при первой ошибке (ненулевом exit code), вместо того чтобы молча продолжать
- **`-u`** — ошибка при использовании необъявленной переменной
- **`-o pipefail`** — ошибка в любой части пайпа останавливает скрипт

Без этого скрипт может «успешно» завершиться, даже если половина команд упала. С этим — ты узнаешь о проблеме сразу.

### 4.10. `shellcheck` — линтер для скриптов

**Установи и используй [shellcheck](https://www.shellcheck.net/)** — он находит баги в bash-скриптах:

Bash

```
# Установка (Ubuntu/Debian)
sudo apt install shellcheck

# Использование
shellcheck backup.sh
```

Это **первое**, что должен установить начинающий скриптописец. Можно также использовать [онлайн-версию](https://www.shellcheck.net/).

### 4.11. `.bashrc` и `.profile` — настройка окружения

Помнишь скрытые файлы `.bashrc` и `.profile` из `ls -a`? Вот для чего они:

**`.bashrc`** — выполняется при каждом открытии терминала. Здесь живут твои настройки:

Bash

```
nano ~/.bashrc
```

Bash

```
# Алиасы — сокращения для частых команд
alias ll='ls -la'
alias gs='git status'
alias gp='git push'
alias ..='cd ..'
alias ...='cd ../..'

# Переменные окружения
export JAVA_HOME=/usr/lib/jvm/java-17
export PATH="$JAVA_HOME/bin:$PATH"
export EDITOR=nano

# Кастомный промпт (по желанию)
PS1='\u@\h:\w\$ '
```

После редактирования примени изменения:

Bash

```
source ~/.bashrc
# или просто открой новый терминал
```

**`.profile`** (или `.bash_profile`) — выполняется при логине. Обычно здесь настраивают `PATH` и переменные окружения.

**Правило:** алиасы и визуальные настройки — в `.bashrc`, переменные окружения — в `.profile`.

### 4.12. Мини-задание «Подмастерье»

text

```
Задание:
─────────────────────────────────────────────────
1. Напиши скрипт greet.sh:
   - Принимает имя как аргумент ($1)
   - Выводит "Hello, Alice!"
   
2. Напиши скрипт count_files.sh:
   - Считает файлы в текущей директории
   - Подсказка: find . -maxdepth 1 -type f | wc -l

3. Напиши скрипт check.sh:
   - Принимает имя файла как аргумент
   - Если файл существует — сообщает
   - Если нет — сообщает

4. Добавь в свой .bashrc алиас:
   alias ll='ls -la'
   Примени: source ~/.bashrc
   Попробуй: ll

Не забудь:
- Первая строка: #!/usr/bin/env bash
- Вторая строка: set -euo pipefail
- chmod +x имя_скрипта.sh
- Проверь скрипт: shellcheck имя_скрипта.sh
─────────────────────────────────────────────────
```

**Решения** (сверься после попытки):

Bash

```
# greet.sh
#!/usr/bin/env bash
set -euo pipefail
echo "Hello, ${1:-World}!"
```

Bash

```
# count_files.sh
#!/usr/bin/env bash
set -euo pipefail
count=$(find . -maxdepth 1 -type f | wc -l)
echo "Файлов в текущей директории: $count"
```

Bash

```
# check.sh
#!/usr/bin/env bash
set -euo pipefail

if [[ -z "${1:-}" ]]; then
    echo "Использование: ./check.sh <имя_файла>"
    exit 1
fi

if [[ -f "$1" ]]; then
    echo "Файл '$1' существует"
else
    echo "Файл '$1' не найден"
fi
```

---

## ФИНАЛЬНОЕ ЗАДАНИЕ: BOSS FIGHT — backup.sh

### Легенда

Ты — начинающий DevOps-инженер. Первое задание:

> «Напиши скрипт, который создаёт резервную копию указанной директории.»

Бэкап-скрипты работают на каждом продакшн-сервере. Именно они спасают данные, когда что-то ломается.

### Требования

Скрипт должен:

1. Принимать аргумент — путь к директории для бэкапа
2. Проверять, что аргумент передан
3. Проверять, что директория существует
4. Проверять, что бэкап за сегодня ещё не создан
5. Создавать директорию `backups/` (если её нет)
6. Создавать tar.gz-архив с датой в имени
7. Логировать действия
8. Сообщать об успехе или ошибке
9. Корректно обрабатывать прерывание (Ctrl+C)

### Попробуй сам!

Потрать 15–20 минут. Тебе понадобятся: `$1`, `if`, `[[ ]]`, `mkdir -p`, `tar`, `date`, `basename`, `echo`, `exit`, `set -euo pipefail`, `trap`, функции.

<details> <summary>Подсказка 1: Дата в переменной</summary>

Bash

```
date_str=$(date +%Y-%m-%d)
echo "$date_str"
# 2025-06-23
```

</details><details> <summary>Подсказка 2: Имя директории из полного пути</summary>

Bash

```
basename /home/user/projects/myapp
# myapp
```

</details><details> <summary>Подсказка 3: Создание tar.gz архива</summary>

Bash

```
# -C позволяет указать рабочую директорию, чтобы в архив 
# не попал полный путь /home/user/projects/...
tar -czf archive.tar.gz -C /path/to/parent dir_name
```

</details><details> <summary>Подсказка 4: trap для очистки</summary>

Bash

```
trap 'rm -f "$backup_path"; echo "Прервано"; exit 1' INT TERM
```

</details>

### Эталонное решение

Bash

```
#!/usr/bin/env bash
set -euo pipefail
# ======================================
# backup.sh — Скрипт резервного копирования
# Использование: ./backup.sh <директория>
# ======================================

# --- Функции ---

log_info() {
    echo "[INFO]  $(date '+%Y-%m-%d %H:%M:%S') $1"
}

log_error() {
    echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $1" >&2
}

show_usage() {
    echo "Использование: ./backup.sh <директория>"
    echo "Пример: ./backup.sh myapp"
    echo "        ./backup.sh /home/user/projects/myapp"
}

# --- Определяем базовую директорию (где лежит скрипт) ---
script_dir="$(cd "$(dirname "$0")" && pwd)"
backup_dir="${script_dir}/backups"

# --- ШАГ A: Проверяем, что аргумент передан ---
if [[ -z "${1:-}" ]]; then
    log_error "Аргумент не передан"
    show_usage
    exit 1
fi

source="$1"

# --- ШАГ Б: Проверяем, что директория существует ---
if [[ ! -d "$source" ]]; then
    log_error "Директория '$source' не найдена"
    exit 1
fi

# --- ШАГ В: Получаем абсолютный путь к источнику ---
source_abs="$(cd "$source" && pwd)"
dir_name=$(basename "$source_abs")
parent_dir=$(dirname "$source_abs")

# --- ШАГ Г: Готовим имя бэкапа ---
date_str=$(date +%Y-%m-%d)
backup_name="${dir_name}_${date_str}.tar.gz"
backup_path="${backup_dir}/${backup_name}"

# --- ШАГ Д: Проверяем, нет ли уже бэкапа за сегодня ---
if [[ -f "$backup_path" ]]; then
    log_error "Бэкап за сегодня уже существует: $backup_path"
    echo "Удалите его вручную, если хотите пересоздать."
    exit 1
fi

# --- ШАГ Е: Создаём папку backups (если её нет) ---
mkdir -p "$backup_dir"

# --- ШАГ Ж: Обработка прерывания (Ctrl+C) ---
trap 'rm -f "$backup_path"; log_error "Прервано, неполный архив удалён"; exit 1' INT TERM

# --- ШАГ З: Создаём архив ---
log_info "Создаю бэкап '$source_abs'..."

# -C parent_dir dir_name — чтобы в архиве был относительный путь,
# а не /home/user/projects/myapp/...
if tar -czf "$backup_path" -C "$parent_dir" "$dir_name"; then
    log_info "Бэкап создан: $backup_path"
    log_info "Размер: $(du -h "$backup_path" | cut -f1)"
else
    log_error "Ошибка при создании бэкапа!"
    rm -f "$backup_path"
    exit 1
fi
```

### Разбор ключевых решений

|Проблема|Решение в скрипте|
|---|---|
|Скрипт запускают из другой директории|`script_dir` вычисляет абсолютный путь|
|Команда падает, но скрипт продолжает|`set -euo pipefail` останавливает при ошибке|
|`cp -r` не сжимает, не сохраняет метаданные|`tar -czf` — архив с gzip-сжатием|
|Полный путь попадает в архив|`-C parent_dir dir_name` сохраняет только относительный|
|Перезапись существующего бэкапа|Проверка `[[ -f "$backup_path" ]]`|
|Ctrl+C во время архивирования → битый файл|`trap` удаляет неполный архив|
|Непонятно, что делает скрипт|Функции `log_info` / `log_error`|
|Ошибки смешиваются с обычным выводом|`>&2` отправляет ошибки в stderr|

### Тестируем

Bash

```
chmod +x backup.sh

# Создаём тестовый проект
mkdir -p testproject/src
echo "public class Main {}" > testproject/src/Main.java
echo "# My Project" > testproject/README.md

# Запуск
./backup.sh testproject
# [INFO]  2025-06-23 14:30:00 Создаю бэкап '/home/user/testproject'...
# [INFO]  2025-06-23 14:30:00 Бэкап создан: /home/user/backups/testproject_2025-06-23.tar.gz
# [INFO]  2025-06-23 14:30:00 Размер: 4.0K

# Проверяем содержимое архива
tar -tzf backups/testproject_2025-06-23.tar.gz
# testproject/
# testproject/README.md
# testproject/src/
# testproject/src/Main.java

# Повторный запуск
./backup.sh testproject
# [ERROR] Бэкап за сегодня уже существует: ...

# Без аргументов
./backup.sh
# [ERROR] Аргумент не передан

# Несуществующая папка
./backup.sh nonexistent
# [ERROR] Директория 'nonexistent' не найдена

# Не забудь проверить через shellcheck!
shellcheck backup.sh
```

### Задания со звёздочкой

**★ Добавь время к имени** (несколько бэкапов в день):

Bash

```
date_str=$(date +%Y-%m-%d_%H-%M-%S)
# Результат: testproject_2025-06-23_14-30-00.tar.gz
```

**★★ Удаление старых бэкапов** (добавь в конец скрипта):

Bash

```
# Удалить бэкапы старше 7 дней
if [[ -d "$backup_dir" ]]; then
    log_info "Проверяю старые бэкапы..."
    old_backups=$(find "$backup_dir" -mindepth 1 -maxdepth 1 -mtime +7 -print)
    if [[ -n "$old_backups" ]]; then
        echo "Будут удалены:"
        echo "$old_backups"
        find "$backup_dir" -mindepth 1 -maxdepth 1 -mtime +7 -delete
        log_info "Очистка завершена"
    else
        log_info "Старых бэкапов не найдено"
    fi
fi
```

**★★★ Несколько директорий:**

Bash

```
#!/usr/bin/env bash
set -euo pipefail

if [[ $# -eq 0 ]]; then
    echo "Использование: ./backup.sh <дир1> [дир2] [дир3] ..."
    exit 1
fi

script_dir="$(cd "$(dirname "$0")" && pwd)"
backup_dir="${script_dir}/backups"
date_str=$(date +%Y-%m-%d_%H-%M-%S)
mkdir -p "$backup_dir"

for source in "$@"; do
    if [[ ! -d "$source" ]]; then
        echo "-- Пропускаю '$source': директория не найдена" >&2
        continue
    fi

    source_abs="$(cd "$source" && pwd)"
    dir_name=$(basename "$source_abs")
    parent_dir=$(dirname "$source_abs")
    backup_path="${backup_dir}/${dir_name}_${date_str}.tar.gz"

    if tar -czf "$backup_path" -C "$parent_dir" "$dir_name"; then
        echo "Бэкап создан: $backup_path"
    else
        echo "Ошибка при бэкапе '$source'" >&2
        rm -f "$backup_path"
    fi
done
```

---

## УРОВЕНЬ 5: Продвинутые инструменты

Ты освоил базу. Теперь — инструменты, которые нужны Java-разработчику в повседневной работе.

### 5.1. Управление процессами

#### Просмотр процессов

Bash

```
ps aux                     # все процессы в системе
ps aux | grep java         # найти Java-процессы
```

#### Остановка процессов

Bash

```
# Найти PID (идентификатор процесса)
ps aux | grep java
# user  12345  ... java -jar myapp.jar

# Мягкое завершение (SIGTERM — программа может корректно закрыться)
kill 12345

# Жёсткое завершение (SIGKILL — немедленно, без шанса на очистку)
kill -9 12345
```

#### Фоновые процессы

Bash

```
# Запустить в фоне (& в конце)
java -jar myapp.jar &
# [1] 12345              ← номер задачи и PID

# Ctrl+Z — приостановить текущий процесс
# bg — продолжить в фоне
# fg — вернуть на передний план

# Пример: запустил приложение, оно заняло терминал
java -jar myapp.jar
# Ctrl+Z
# [1]+  Stopped  java -jar myapp.jar
bg
# [1]+ java -jar myapp.jar &
# Теперь приложение работает в фоне, терминал свободен

# Вернуть обратно
fg

# Список фоновых задач
jobs
```

**Типичный сценарий Java-разработчика:**

Bash

```
# Запустить приложение в фоне, логи в файл
java -jar myapp.jar > app.log 2>&1 &
echo $!    # PID последнего фонового процесса

# Следить за логами
tail -f app.log

# Остановить
kill $(cat app.pid)    # или kill с PID из ps
```

### 5.2. Сеть: `curl` и `wget`

#### `curl` — HTTP-запросы из терминала

Для Java-разработчика — проверка REST API, healthcheck'и, отладка:

Bash

```
# Простой GET-запрос
curl http://localhost:8080/health
# {"status":"UP"}

# Тихий режим (без прогресс-бара)
curl -s http://localhost:8080/api/users

# С заголовками ответа
curl -i http://localhost:8080/api/users

# POST с JSON
curl -X POST http://localhost:8080/api/users \
  -H "Content-Type: application/json" \
  -d '{"name": "Alice", "email": "alice@example.com"}'

# Сохранить ответ в файл
curl -s http://localhost:8080/api/users > users.json

# Проверить только код ответа
curl -s -o /dev/null -w "%{http_code}" http://localhost:8080/health
# 200
```

#### `wget` — скачивание файлов

Bash

```
# Скачать файл
wget https://example.com/artifact.jar

# Скачать с другим именем
wget -O myapp.jar https://example.com/releases/v1.0/app.jar
```

### 5.3. SSH — подключение к серверам

SSH упоминался как причина учить терминал. Вот практика:

#### Генерация ключа

Bash

```
ssh-keygen -t ed25519 -C "your_email@example.com"
# Нажми Enter для дефолтного пути (~/.ssh/id_ed25519)
# Введи пароль (или пустой для без пароля)

# ОБЯЗАТЕЛЬНО: правильные права на ключи
chmod 600 ~/.ssh/id_ed25519       # приватный ключ
chmod 644 ~/.ssh/id_ed25519.pub   # публичный ключ
chmod 700 ~/.ssh                  # директория
```

> ⚠️ SSH **откажется работать**, если права на ключи слишком открытые. `chmod 600` — обязательно.

#### Подключение

Bash

```
# Подключиться к серверу
ssh user@192.168.1.100
ssh user@myserver.com

# Подключиться и сразу выполнить команду
ssh user@server "ls -la /var/log"

# Копирование файлов между машинами
scp file.txt user@server:/home/user/
scp user@server:/var/log/app.log ./local_copy.log

# Копирование директории
scp -r myproject/ user@server:/home/user/
```

### 5.4. Мини-задание «Оператор»

text

```
Задание:
─────────────────────────────────────────────────
1. Запусти длинную команду в фоне:
   sleep 60 &

2. Посмотри фоновые задачи:
   jobs

3. Найди процесс sleep:
   ps aux | grep sleep

4. Останови его:
   kill %1     (по номеру задачи)

5. Сделай HTTP-запрос (если есть доступ в сеть):
   curl -s https://httpbin.org/get | less

6. Сгенерируй SSH-ключ (если ещё не делал):
   ssh-keygen -t ed25519
   ls -la ~/.ssh/

7. Создай конфигурационный файл через heredoc:
   cat <<EOF > app.properties
   server.port=8080
   spring.profiles.active=dev
   logging.level.root=INFO
   EOF
   cat app.properties
─────────────────────────────────────────────────
```

---

## Заключение: Что дальше

### Что ты освоил

|Навык|Команды|
|---|---|
|Навигация|`pwd`, `ls`, `cd`, `.`, `..`, `~`, `tree`, `whoami`|
|Создание и удаление|`mkdir`, `touch`, `cp`, `mv`, `rm`, `ln -s`|
|Просмотр и сравнение|`cat`, `less`, `head`, `tail`, `nano`, `diff`|
|Потоки и пайпы|`\|`, `>`, `>>`, `2>`, `2>&1`, `tee`|
|Поиск и фильтрация|`grep`, `find`, `xargs`, `sort`, `uniq`, `wc`|
|Скриптинг|shebang, переменные, `if`/`[[ ]]`, `for`, `while read`, функции, heredoc|
|Безопасность скриптов|`set -euo pipefail`, `trap`, `shellcheck`, exit codes|
|Права и владение|`chmod` (символьная и числовая), `chown`|
|Процессы|`ps`, `kill`, `&`, `bg`/`fg`, `jobs`|
|Сеть|`curl`, `wget`, `ssh`, `scp`, `ssh-keygen`|
|Настройка окружения|`.bashrc`, `.profile`, `alias`, `export`, `PATH`|
|Инструменты|`man`, `tar`, `which`, `history`|

### Связь с Java Roadmap

Терминал — фундамент. Без него не работают:

- **Git** → `git add`, `git commit`, `git push`
- **Maven/Gradle** → `mvn clean install`, `gradle build`
- **Docker** → `docker run`, `docker-compose up`
- **SSH** → `ssh user@server`
- **CI/CD** → все пайплайны — по сути, bash-скрипты

Всё, что ты изучил сегодня, будет использоваться каждый день.

---

## Cheat Sheet Властелина

20 команд — краткая шпаргалка.

|#|Команда|Прозвище|Что делает|
|---|---|---|---|
|1|`pwd`|📍 GPS|Показывает, где ты сейчас|
|2|`ls -la`|👁 Рентген|Всё: скрытые, права, размер|
|3|`cd`|🚀 Телепорт|Перейти в другую директорию|
|4|`mkdir -p`|🏗 Строитель|Создать директорию (с вложенными)|
|5|`touch`|✨ Создатель|Создать пустой файл|
|6|`cp -a`|📋 Клонер|Копировать (с метаданными)|
|7|`mv`|📦 Грузчик|Переместить / переименовать|
|8|`rm -i`|💀 Разрушитель|Удалить (с подтверждением)|
|9|`cat` / `less`|📖 Читатель|Показать содержимое файла|
|10|`head` / `tail -f`|🔝🔚 Края|Начало / конец файла (live-мониторинг)|
|11|`grep -rn`|🔍 Ищейка|Поиск текста рекурсивно с номерами строк|
|12|`find`|🗺 Картограф|Поиск файлов по имени, размеру, дате|
|13|`wc -l`|🔢 Счетовод|Подсчёт строк|
|14|`\|`|🔧 Пайп|Труба: выход одной → вход другой|
|15|`> / >> / 2>&1`|📝 Писарь|Перенаправление stdout и stderr|
|16|`chmod` / `chown`|🔑 Ключник|Права доступа и владелец|
|17|`tar -czf`|📦 Упаковщик|Создать gzip-архив|
|18|`curl`|🌐 Связист|HTTP-запросы|
|19|`ps` / `kill`|⚙️ Диспетчер|Процессы: просмотр и управление|
|20|`man`|📚 Мудрец|Документация по любой команде|

**Бонус — клавиши:**

|Клавиша|Действие|
|---|---|
|`Tab`|Автодополнение (самая полезная!)|
|`↑` / `↓`|Листать историю команд|
|`Ctrl + C`|Прервать выполнение|
|`Ctrl + Z`|Приостановить процесс|
|`Ctrl + L`|Очистить экран|
|`Ctrl + R`|Поиск по истории команд|
|`Ctrl + D`|Выход из терминала / EOF|

---

## Troubleshooting

### «Command not found»

```sh
bash: jav: command not found
```

**Что это значит:** Система не может найти программу с таким именем.

**Чек-лист решения:**

|#|Проверка|Команда|
|---|---|---|
|1|**Опечатка?**|Перечитай команду. `jav` ≠ `java`, `gti` ≠ `git`|
|2|**Программа установлена?**|`which java` или `whereis java`|
|3|**Программа в PATH?**|`echo $PATH` — проверь список директорий|
|4|**Нужно установить?**|Ubuntu: `sudo apt install имя_пакета` / Mac: `brew install имя_пакета`|
|5|**Локальный скрипт?**|Используй `./script.sh`, а не просто `script.sh`|
|6|**Добавить в PATH?**|`export PATH="/путь/к/программе:$PATH"` (в `.bashrc` для постоянного эффекта)|

**Пример — Java не найдена:**

```bash
java -version
# bash: java: command not found

# Решение (Ubuntu):
sudo apt install default-jdk

# Решение (Mac):
brew install openjdk
```

**Пример — свой скрипт не найден:**

```sh
backup.sh
# command not found

# Решение: укажи путь явно
./backup.sh
```

---

### «Permission denied»


```sh
bash: ./backup.sh: Permission denied
```

**Что это значит:** У тебя нет прав на выполнение этого действия.

**Чек-лист решения:**

|#|Ситуация|Решение|
|---|---|---|
|1|**Запускаешь скрипт**|`chmod +x script.sh` — добавь право на исполнение|
|2|**Нет доступа к файлу**|`ls -l файл` — проверь, кто владелец и какие права|
|3|**Нужны права root**|Добавь `sudo` перед командой|
|4|**Нет доступа к директории**|`chmod +x директория` — нужно право `x` чтобы заходить|
|5|**Docker создал файлы от root**|`sudo chown -R $(whoami):$(whoami) ./папка/`|

**Пример — запуск скрипта:**

```sh
./hello.sh
# Permission denied

ls -l hello.sh
# -rw-r--r-- 1 user user 89 Jun 23 12:00 hello.sh
#  ↑ нет x — нельзя исполнять

chmod +x hello.sh
./hello.sh
# Работает!
```

**Пример — SSH-ключ:**

```sh
ssh user@server
# WARNING: UNPROTECTED PRIVATE KEY FILE!
# Permissions 0644 for '/home/user/.ssh/id_ed25519' are too open.

chmod 600 ~/.ssh/id_ed25519
ssh user@server
# Работает!
```

---

### О `sudo` — кратко и важно

`sudo` = **S**ubstitute **U**ser **Do** — выполнить команду от имени суперпользователя (root).

Bash

```
sudo apt install git    # установить пакет (требует root)
sudo nano /etc/hosts    # редактировать системный файл
```

Система спросит **твой пароль** (не root-пароль).

**Принцип наименьших привилегий:** используй `sudo` **только когда без него нельзя** (установка пакетов, изменение системных файлов). Для работы со своими файлами в домашней директории `sudo` не нужен.

> ⚠️ **Никогда** не запускай `sudo rm -rf /` и подобные команды из интернета. `sudo` даёт полные права — можно уничтожить систему.

---

### Другие частые ошибки

|Ошибка|Причина|Решение|
|---|---|---|
|`No such file or directory`|Файл/папка не существует, или опечатка в пути|`ls` — проверь, что есть; `pwd` — проверь, где ты|
|`File exists`|Пытаешься создать то, что уже есть|Проверь `ls`, используй другое имя|
|`Is a directory`|Пытаешься `cat` или `rm` (без `-r`) на директорию|Добавь `-r` для `rm`, используй `ls` для директорий|
|`syntax error near unexpected token`|Ошибка синтаксиса в скрипте|Проверь пробелы в `[[ ]]`, закрывающие `fi`/`done`, кавычки|
|`$'\r': command not found`|Файл создан в Windows (CRLF вместо LF)|`dos2unix script.sh` или в редакторе: сохрани с LF|
|`Argument list too long`|Слишком много файлов в `*` (glob expansion)|Используй `find ... \| xargs ...` вместо `rm *`|

> **Совет:** если скрипт ведёт себя странно — прогони через `shellcheck script.sh`. Он объяснит проблему человеческим языком.

---

> _Командная строка — это не магия. Это язык. Каждая команда — глагол. Скрипт — предложение. Цепочка пайпов — абзац. Ты не заучиваешь 500 команд — ты учишь 20 базовых и комбинируешь их, как слова в речи._